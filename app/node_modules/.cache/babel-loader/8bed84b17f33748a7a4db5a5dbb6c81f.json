{"ast":null,"code":"'use strict';\n/**\n * request.js\n *\n * Request class contains server only options\n */\n\nconst url = require('url');\n\nconst Headers = require('./headers.js');\n\nconst Body = require('./body.js');\n\nconst clone = Body.clone;\nconst extractContentType = Body.extractContentType;\nconst getTotalBytes = Body.getTotalBytes;\nconst PARSED_URL = Symbol('url');\n/**\n * Request class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\n\nclass Request {\n  constructor(input, init) {\n    if (!init) init = {};\n    let parsedURL; // normalize input\n\n    if (!(input instanceof Request)) {\n      if (input && input.href) {\n        // in order to support Node.js' Url objects; though WHATWG's URL objects\n        // will fall into this branch also (since their `toString()` will return\n        // `href` property anyway)\n        parsedURL = url.parse(input.href);\n      } else {\n        // coerce input to a string before attempting to parse\n        parsedURL = url.parse(`${input}`);\n      }\n\n      input = {};\n    } else {\n      parsedURL = url.parse(input.url);\n    }\n\n    let method = init.method || input.method || 'GET';\n\n    if ((init.body != null || input instanceof Request && input.body !== null) && (method === 'GET' || method === 'HEAD')) {\n      throw new TypeError('Request with GET/HEAD method cannot have body');\n    }\n\n    let inputBody = init.body != null ? init.body : input instanceof Request && input.body !== null ? clone(input) : null;\n    Body.call(this, inputBody, {\n      timeout: init.timeout || input.timeout || 0,\n      size: init.size || input.size || 0\n    }); // fetch spec options\n\n    this.method = method.toUpperCase();\n    this.redirect = init.redirect || input.redirect || 'follow';\n    this.headers = new Headers(init.headers || input.headers || {});\n\n    if (init.body != null) {\n      const contentType = extractContentType(this);\n\n      if (contentType !== null && !this.headers.has('Content-Type')) {\n        this.headers.append('Content-Type', contentType);\n      }\n    } // server only options\n\n\n    this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n    this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n    this.counter = init.counter || input.counter || 0;\n    this.agent = init.agent || input.agent;\n    this[PARSED_URL] = parsedURL;\n    Object.defineProperty(this, Symbol.toStringTag, {\n      value: 'Request',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n  }\n\n  get url() {\n    return url.format(this[PARSED_URL]);\n  }\n  /**\n   * Clone this request\n   *\n   * @return  Request\n   */\n\n\n  clone() {\n    return new Request(this);\n  }\n\n}\n\nBody.mixIn(Request.prototype);\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\n  value: 'RequestPrototype',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\nexports = module.exports = Request;\n\nexports.getNodeRequestOptions = function getNodeRequestOptions(request) {\n  const parsedURL = request[PARSED_URL];\n  const headers = new Headers(request.headers); // fetch step 3\n\n  if (!headers.has('Accept')) {\n    headers.set('Accept', '*/*');\n  } // Basic fetch\n\n\n  if (!parsedURL.protocol || !parsedURL.hostname) {\n    throw new TypeError('Only absolute URLs are supported');\n  }\n\n  if (!/^https?:$/.test(parsedURL.protocol)) {\n    throw new TypeError('Only HTTP(S) protocols are supported');\n  } // HTTP-network-or-cache fetch steps 5-9\n\n\n  let contentLengthValue = null;\n\n  if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\n    contentLengthValue = '0';\n  }\n\n  if (request.body != null) {\n    const totalBytes = getTotalBytes(request);\n\n    if (typeof totalBytes === 'number') {\n      contentLengthValue = String(totalBytes);\n    }\n  }\n\n  if (contentLengthValue) {\n    headers.set('Content-Length', contentLengthValue);\n  } // HTTP-network-or-cache fetch step 12\n\n\n  if (!headers.has('User-Agent')) {\n    headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');\n  } // HTTP-network-or-cache fetch step 16\n\n\n  if (request.compress) {\n    headers.set('Accept-Encoding', 'gzip,deflate');\n  }\n\n  if (!headers.has('Connection') && !request.agent) {\n    headers.set('Connection', 'close');\n  } // HTTP-network fetch step 4\n  // chunked encoding is handled by Node.js\n\n\n  return Object.assign({}, parsedURL, {\n    method: request.method,\n    headers: headers.raw(),\n    agent: request.agent\n  });\n};","map":null,"metadata":{},"sourceType":"script"}