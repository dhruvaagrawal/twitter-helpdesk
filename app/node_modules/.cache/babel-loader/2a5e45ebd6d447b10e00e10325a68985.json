{"ast":null,"code":"'use strict';\n\nconst config = require('./config.js');\n\nconst errors = require('./errors.js');\n\nconst LRU = require('lru-cache');\n\nmodule.exports = checkResponse;\n\nfunction checkResponse(method, res, registry, startTime, opts) {\n  opts = config(opts);\n\n  if (res.headers.has('npm-notice') && !res.headers.has('x-local-cache')) {\n    opts.log.notice('', res.headers.get('npm-notice'));\n  }\n\n  checkWarnings(res, registry, opts);\n\n  if (res.status >= 400) {\n    logRequest(method, res, startTime, opts);\n    return checkErrors(method, res, startTime, opts);\n  } else {\n    res.body.on('end', () => logRequest(method, res, startTime, opts));\n\n    if (opts.ignoreBody) {\n      res.body.resume();\n      res.body = null;\n    }\n\n    return res;\n  }\n}\n\nfunction logRequest(method, res, startTime, opts) {\n  const elapsedTime = Date.now() - startTime;\n  const attempt = res.headers.get('x-fetch-attempts');\n  const attemptStr = attempt && attempt > 1 ? ` attempt #${attempt}` : '';\n  const cacheStr = res.headers.get('x-local-cache') ? ' (from cache)' : '';\n  let urlStr;\n\n  try {\n    const URL = require('url').URL;\n\n    const url = new URL(res.url);\n\n    if (url.password) {\n      url.password = '***';\n    }\n\n    urlStr = url.toString();\n  } catch (er) {\n    urlStr = res.url;\n  }\n\n  opts.log.http('fetch', `${method.toUpperCase()} ${res.status} ${urlStr} ${elapsedTime}ms${attemptStr}${cacheStr}`);\n}\n\nconst WARNING_REGEXP = /^\\s*(\\d{3})\\s+(\\S+)\\s+\"(.*)\"\\s+\"([^\"]+)\"/;\nconst BAD_HOSTS = new LRU({\n  max: 50\n});\n\nfunction checkWarnings(res, registry, opts) {\n  if (res.headers.has('warning') && !BAD_HOSTS.has(registry)) {\n    const warnings = {};\n    res.headers.raw()['warning'].forEach(w => {\n      const match = w.match(WARNING_REGEXP);\n\n      if (match) {\n        warnings[match[1]] = {\n          code: match[1],\n          host: match[2],\n          message: match[3],\n          date: new Date(match[4])\n        };\n      }\n    });\n    BAD_HOSTS.set(registry, true);\n\n    if (warnings['199']) {\n      if (warnings['199'].message.match(/ENOTFOUND/)) {\n        opts.log.warn('registry', `Using stale data from ${registry} because the host is inaccessible -- are you offline?`);\n      } else {\n        opts.log.warn('registry', `Unexpected warning for ${registry}: ${warnings['199'].message}`);\n      }\n    }\n\n    if (warnings['111']) {\n      // 111 Revalidation failed -- we're using stale data\n      opts.log.warn('registry', `Using stale data from ${registry} due to a request error during revalidation.`);\n    }\n  }\n}\n\nfunction checkErrors(method, res, startTime, opts) {\n  return res.buffer().catch(() => null).then(body => {\n    let parsed = body;\n\n    try {\n      parsed = JSON.parse(body.toString('utf8'));\n    } catch (e) {}\n\n    if (res.status === 401 && res.headers.get('www-authenticate')) {\n      const auth = res.headers.get('www-authenticate').split(/,\\s*/).map(s => s.toLowerCase());\n\n      if (auth.indexOf('ipaddress') !== -1) {\n        throw new errors.HttpErrorAuthIPAddress(method, res, parsed, opts.spec);\n      } else if (auth.indexOf('otp') !== -1) {\n        throw new errors.HttpErrorAuthOTP(method, res, parsed, opts.spec);\n      } else {\n        throw new errors.HttpErrorAuthUnknown(method, res, parsed, opts.spec);\n      }\n    } else if (res.status === 401 && body != null && /one-time pass/.test(body.toString('utf8'))) {\n      // Heuristic for malformed OTP responses that don't include the www-authenticate header.\n      throw new errors.HttpErrorAuthOTP(method, res, parsed, opts.spec);\n    } else {\n      throw new errors.HttpErrorGeneral(method, res, parsed, opts.spec);\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"script"}