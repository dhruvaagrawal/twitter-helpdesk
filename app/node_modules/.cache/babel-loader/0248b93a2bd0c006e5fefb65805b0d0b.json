{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst validate = require('aproba');\n\nconst fs = require('graceful-fs');\n\nconst isInside = require('path-is-inside');\n\nconst vacuum = require('fs-vacuum');\n\nconst chain = require('slide').chain;\n\nconst asyncMap = require('slide').asyncMap;\n\nconst readCmdShim = require('read-cmd-shim');\n\nconst iferr = require('iferr');\n\nexports = module.exports = rm;\n\nfunction rm(target, opts, cb) {\n  var targetPath = path.normalize(path.resolve(opts.prefix, target));\n\n  if (opts.prefixes.indexOf(targetPath) !== -1) {\n    return cb(new Error('May not delete: ' + targetPath));\n  }\n\n  var options = {};\n\n  if (opts.force) {\n    options.purge = true;\n  }\n\n  if (opts.base) options.base = path.normalize(path.resolve(opts.prefix, opts.base));\n\n  if (!opts.gently) {\n    options.purge = true;\n    return vacuum(targetPath, options, cb);\n  }\n\n  var parent = options.base = options.base || path.normalize(opts.prefix); // Do all the async work we'll need to do in order to tell if this is a\n  // safe operation\n\n  chain([[isEverInside, parent, opts.prefixes, opts.log], [readLinkOrShim, targetPath], [isEverInside, targetPath, opts.prefixes, opts.log], [isEverInside, targetPath, [parent], opts.log]], function (er, results) {\n    if (er) {\n      if (er.code === 'ENOENT') return cb();\n      return cb(er);\n    }\n\n    var parentInfo = {\n      path: parent,\n      managed: results[0]\n    };\n    var targetInfo = {\n      path: targetPath,\n      symlink: results[1],\n      managed: results[2],\n      inParent: results[3]\n    };\n    isSafeToRm(parentInfo, targetInfo, opts.name, opts.log, iferr(cb, thenRemove));\n\n    function thenRemove(toRemove, removeBase) {\n      if (!toRemove) return cb();\n      if (removeBase) options.base = removeBase;\n      return vacuum(toRemove, options, cb);\n    }\n  });\n}\n\nexports._isSafeToRm = isSafeToRm;\n\nfunction isSafeToRm(parent, target, pkgName, log, cb) {\n  log.silly('gentlyRm', 'parent.path =', parent.path);\n  log.silly('gentlyRm', 'parent.managed =', parent.managed && parent.managed.target + ' is in ' + parent.managed.path);\n  log.silly('gentlyRm', 'target.path = ', target.path);\n  log.silly('gentlyRm', 'target.symlink =', target.symlink);\n  log.silly('gentlyRm', 'target.managed =', target.managed && target.managed.target + ' is in ' + target.managed.path);\n  log.silly('gentlyRm', 'target.inParent = ', target.inParent); // The parent directory or something it symlinks to must eventually be in\n  // a folder that we maintain.\n\n  if (!parent.managed) {\n    log.info('gentlyRm', parent.path, 'is not contained in any directory ' + pkgName + ' is known to control or ' + 'any place they link to');\n    return cb(clobberFail(target.path, 'containing path ' + parent.path + \" isn't under \" + pkgName + \"'s control\"));\n  } // The target or something it symlinks to must eventually be in the parent\n  // or something the parent symlinks to\n\n\n  if (target.inParent) {\n    var actualTarget = target.inParent.target;\n    var targetsParent = target.inParent.path; // if the target.path was what we found in some version of parent, remove\n    // using that parent as the base\n\n    if (target.path === actualTarget) {\n      return cb(null, target.path, targetsParent);\n    } else {\n      // If something the target.path links to was what was found, just\n      // remove target.path in the location it was found.\n      return cb(null, target.path, path.dirname(target.path));\n    }\n  } // If the target is in a managed directory and is in a symlink, but was\n  // not in our parent that usually means someone else installed a bin file\n  // with the same name as one of our bin files.\n\n\n  if (target.managed && target.symlink) {\n    log.warn('rm', 'not removing', target.path, \"as it wasn't installed by\", parent.path);\n    return cb();\n  }\n\n  if (target.symlink) {\n    return cb(clobberFail(target.path, target.symlink + ' symlink target is not controlled by ' + pkgName + ' ' + parent.path));\n  } else {\n    return cb(clobberFail(target.path, 'is outside ' + parent.path + ' and not a link'));\n  }\n}\n\nfunction clobberFail(target, msg) {\n  validate('SS', arguments);\n  var er = new Error('Refusing to delete ' + target + ': ' + msg);\n  er.code = 'EEXIST';\n  er.path = target;\n  return er;\n}\n\nfunction isENOENT(err) {\n  return err && err.code === 'ENOENT';\n}\n\nfunction notENOENT(err) {\n  return !isENOENT(err);\n}\n\nfunction skipENOENT(cb) {\n  return function (err, value) {\n    if (isENOENT(err)) {\n      return cb(null, false);\n    } else {\n      return cb(err, value);\n    }\n  };\n}\n\nfunction errorsToValues(fn) {\n  return function () {\n    var args = Array.prototype.slice.call(arguments);\n    var cb = args.pop();\n    args.push(function (err, value) {\n      if (err) {\n        return cb(null, err);\n      } else {\n        return cb(null, value);\n      }\n    });\n    fn.apply(null, args);\n  };\n}\n\nfunction isNotError(value) {\n  return !(value instanceof Error);\n}\n\nexports._isEverInside = isEverInside; // return the first of path, where target (or anything it symlinks to)\n// isInside the path (or anything it symlinks to)\n\nfunction isEverInside(target, paths, log, cb) {\n  validate('SAOF', arguments);\n  asyncMap(paths, errorsToValues(readAllLinks), iferr(cb, function (resolvedPaths) {\n    var errorFree = resolvedPaths.filter(isNotError);\n\n    if (errorFree.length === 0) {\n      var badErrors = resolvedPaths.filter(notENOENT);\n\n      if (badErrors.length === 0) {\n        return cb(null, false);\n      } else {\n        return cb(badErrors[0]);\n      }\n    }\n\n    readAllLinks(target, iferr(skipENOENT(cb), function (targets) {\n      cb(null, areAnyInsideAny(targets, errorFree, log));\n    }));\n  }));\n}\n\nexports._areAnyInsideAny = areAnyInsideAny; // Return the first path found that any target is inside\n\nfunction areAnyInsideAny(targets, paths, log) {\n  validate('AAO', arguments);\n  var toCheck = [];\n  paths.forEach(function (path) {\n    targets.forEach(function (target) {\n      toCheck.push([target, path]);\n    });\n  });\n\n  for (var ii = 0; ii < toCheck.length; ++ii) {\n    var target = toCheck[ii][0];\n    var path = toCheck[ii][1];\n    var inside = isInside(target, path);\n    if (!inside) log.silly('isEverInside', target, 'is not inside', path);\n    if (inside && path) return inside && path && {\n      target: target,\n      path: path\n    };\n  }\n\n  return false;\n}\n\nexports._readAllLinks = readAllLinks; // resolves chains of symlinks of unlimited depth, returning a list of paths\n// it's seen in the process when it hits either a symlink cycle or a\n// non-symlink\n\nfunction readAllLinks(path, cb) {\n  validate('SF', arguments);\n  var seen = {};\n\n  _readAllLinks(path);\n\n  function _readAllLinks(path) {\n    if (seen[path]) return cb(null, Object.keys(seen));\n    seen[path] = true;\n    resolveSymlink(path, iferr(cb, _readAllLinks));\n  }\n}\n\nexports._resolveSymlink = resolveSymlink;\nvar resolvedPaths = {};\n\nfunction resolveSymlink(symlink, cb) {\n  validate('SF', arguments);\n  var cached = resolvedPaths[symlink];\n  if (cached) return cb(null, cached);\n  readLinkOrShim(symlink, iferr(cb, function (symlinkTarget) {\n    if (symlinkTarget) {\n      resolvedPaths[symlink] = path.resolve(path.dirname(symlink), symlinkTarget);\n    } else {\n      resolvedPaths[symlink] = symlink;\n    }\n\n    return cb(null, resolvedPaths[symlink]);\n  }));\n}\n\nexports._readLinkOrShim = readLinkOrShim;\n\nfunction readLinkOrShim(path, cb) {\n  validate('SF', arguments);\n  fs.lstat(path, iferr(cb, function (stat) {\n    if (stat.isSymbolicLink()) {\n      fs.readlink(path, cb);\n    } else {\n      readCmdShim(path, function (er, source) {\n        if (!er) return cb(null, source); // lstat wouldn't return an error on these, so we don't either.\n\n        if (er.code === 'ENOTASHIM' || er.code === 'EISDIR') {\n          return cb(null, null);\n        } else {\n          return cb(er);\n        }\n      });\n    }\n  }));\n}","map":null,"metadata":{},"sourceType":"script"}