{"ast":null,"code":"\"use strict\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar helpers = require('./helpers');\n\nvar forge = require('node-forge');\n\nvar pki = forge.pki,\n    rsa = forge.rsa;\n\nvar _require = require('./constants'),\n    DEFAULT_MESSAGE_DIGEST = _require.DEFAULT_MESSAGE_DIGEST,\n    DEFAULT_AES_KEY_SIZE = _require.DEFAULT_AES_KEY_SIZE,\n    DEFAULT_AES_IV_SIZE = _require.DEFAULT_AES_IV_SIZE,\n    AES_STANDARD = _require.AES_STANDARD,\n    RSA_STANDARD = _require.RSA_STANDARD;\n\nvar Crypt = /*#__PURE__*/function () {\n  function Crypt() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Crypt);\n\n    this.options = _objectSpread({\n      md: DEFAULT_MESSAGE_DIGEST,\n      aesKeySize: DEFAULT_AES_KEY_SIZE,\n      aesIvSize: DEFAULT_AES_IV_SIZE,\n      aesStandard: AES_STANDARD,\n      rsaStandard: RSA_STANDARD,\n      entropy: undefined\n    }, options); // Add some entropy if available\n\n    if (this.options.entropy) {\n      this._entropy(this.options.entropy);\n    }\n  }\n  /**\n   * Returns message digest by type\n   *\n   * @param {String} messageDigest Message digest type as string\n   *\n   * @return {Object} Initialized message digest\n   * @method\n   */\n\n\n  _createClass(Crypt, [{\n    key: \"_getMessageDigest\",\n    value: function _getMessageDigest(messageDigest) {\n      switch (messageDigest) {\n        case 'sha1':\n          return forge.md.sha1.create();\n\n        case 'sha256':\n          return forge.md.sha256.create();\n\n        case 'sha384':\n          return forge.md.sha384.create();\n\n        case 'sha512':\n          return forge.md.sha512.create();\n\n        case 'md5':\n          return forge.md.md5.create();\n\n        default:\n          console.warn(\"Message digest \\\"\".concat(this.options.md, \"\\\" not found. Using default message digest \\\"sha1\\\" instead\"));\n          return forge.md.sha1.create();\n      }\n    }\n    /**\n     * Parses hybrid-crypto-js signature\n     *\n     * @param {String} _signature Signature string. Either JSON formatted string (>= hybrid-crypto-js 0.2.1) or plain signature\n     *\n     * @return {Object} Parsed signature\n     * @method\n     */\n\n  }, {\n    key: \"_parseSignature\",\n    value: function _parseSignature(_signature) {\n      // Try parsing signature string. This works if\n      // signature is generated with hybrid-crypto-js\n      // versions >= 0.2.1.\n      try {\n        return JSON.parse(_signature);\n      } catch (e) {\n        // Fallback to old signature type. This works\n        // with signatures generated with hybrid-cryto-js\n        // versions <= 0.2.0\n        return {\n          signature: _signature,\n          md: 'sha1',\n          v: helpers.version()\n        };\n      }\n    }\n    /**\n     * Returns fingerprint for any public key\n     *\n     * @param {Object} publicKey Forge public key object\n     *\n     * @return {String} Public key's fingerprint\n     * @method\n     */\n\n  }, {\n    key: \"fingerprint\",\n    value: function fingerprint(publicKey) {\n      return pki.getPublicKeyFingerprint(publicKey, {\n        encoding: 'hex',\n        delimiter: ':'\n      });\n    }\n    /**\n     * Signs a message\n     *\n     * @param {String} privateKey Private key in PEM format\n     * @param {String} message Message to sign\n     *\n     * @return {String} Signature and meta data as a JSON formatted string\n     * @method\n     */\n\n  }, {\n    key: \"signature\",\n    value: function signature(privateKey, message) {\n      // Create SHA-1 checksum\n      var checkSum = this._getMessageDigest(this.options.md);\n\n      checkSum.update(message, 'utf8'); // Accept both PEMs and forge private key objects\n\n      if (typeof privateKey === 'string') privateKey = pki.privateKeyFromPem(privateKey);\n      var signature = privateKey.sign(checkSum);\n      var signature64 = forge.util.encode64(signature); // Return signature in JSON format\n\n      return JSON.stringify({\n        signature: signature64,\n        md: this.options.md\n      });\n    }\n    /**\n     * Verifies a message\n     *\n     * @param {String} publicKey Public key in PEM format\n     * @param {String} _signature Signature in JSON string format\n     * @param {String} decrypted Decrypted message\n     *\n     * @return {Boolean} Tells whether verification were successful or not\n     * @method\n     */\n\n  }, {\n    key: \"verify\",\n    value: function verify(publicKey, _signature, decrypted) {\n      // Return false if no signature is defined\n      if (!_signature) return false; // Parse signature object into actual signature and message digest type\n\n      var _this$_parseSignature = this._parseSignature(_signature),\n          signature = _this$_parseSignature.signature,\n          md = _this$_parseSignature.md; // Create SHA-1 checksum\n\n\n      var checkSum = this._getMessageDigest(md);\n\n      checkSum.update(decrypted, 'utf8'); // Base64 decode signature\n\n      signature = forge.util.decode64(signature); // Accept both PEMs and forge private key objects\n\n      if (typeof publicKey === 'string') publicKey = pki.publicKeyFromPem(publicKey); // Verify signature\n\n      return publicKey.verify(checkSum.digest().getBytes(), signature);\n    }\n    /**\n     * Encrypts a message using public RSA key and optional signature\n     *\n     * @param {String[]} publicKeys Public keys in PEM format\n     * @param {String} message Message to encrypt\n     * @param {String} signature Optional signature\n     *\n     * @return {String} Encrypted message and metadata as a JSON formatted string\n     * @method\n     */\n\n  }, {\n    key: \"encrypt\",\n    value: function encrypt(publicKeys, message, signature) {\n      var _this = this; // Generate flat array of keys\n\n\n      publicKeys = helpers.toArray(publicKeys); // Map PEM keys to forge public key objects\n\n      publicKeys = publicKeys.map(function (key) {\n        return typeof key === 'string' ? pki.publicKeyFromPem(key) : key;\n      }); // Generate random keys\n\n      var iv = forge.random.getBytesSync(this.options.aesIvSize);\n      var key = forge.random.getBytesSync(this.options.aesKeySize / 8); // Encrypt random key with all of the public keys\n\n      var encryptedKeys = {};\n      publicKeys.forEach(function (publicKey) {\n        var encryptedKey = publicKey.encrypt(key, _this.options.rsaStandard);\n\n        var fingerprint = _this.fingerprint(publicKey);\n\n        encryptedKeys[fingerprint] = forge.util.encode64(encryptedKey);\n      }); // Create buffer and cipher\n\n      var buffer = forge.util.createBuffer(message, 'utf8');\n      var cipher = forge.cipher.createCipher(this.options.aesStandard, key); // Actual encryption\n\n      cipher.start({\n        iv: iv\n      });\n      cipher.update(buffer);\n      cipher.finish(); // Attach encrypted message int payload\n\n      var payload = {};\n      payload.v = helpers.version();\n      payload.iv = forge.util.encode64(iv);\n      payload.keys = encryptedKeys;\n      payload.cipher = forge.util.encode64(cipher.output.data);\n      payload.signature = signature;\n      payload.tag = cipher.mode.tag && forge.util.encode64(cipher.mode.tag.getBytes()); // Return encrypted message\n\n      return JSON.stringify(payload);\n    }\n    /**\n     * Decrypts a message using private RSA key\n     *\n     * @param {String} privateKey Private key in PEM format\n     * @param {String} encrypted Message to decrypt\n     *\n     * @return {Object} Decrypted message and metadata as a JSON object\n     * @method\n     */\n\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(privateKey, encrypted) {\n      // Validate encrypted message\n      this._validate(encrypted); // Parse encrypted string to JSON\n\n\n      var payload = JSON.parse(encrypted); // Accept both PEMs and forge private key objects\n      // Cast PEM to forge private key object\n\n      if (typeof privateKey === 'string') privateKey = pki.privateKeyFromPem(privateKey); // Get key fingerprint\n\n      var fingerprint = this.fingerprint(privateKey); // Get encrypted keys and encrypted message from the payload\n\n      var encryptedKey = payload.keys[fingerprint]; // Log error if key wasn't found\n\n      if (!encryptedKey) throw \"RSA fingerprint doesn't match with any of the encrypted message's fingerprints\"; // Get bytes of encrypted AES key, initialization vector and cipher\n\n      var keyBytes = forge.util.decode64(encryptedKey);\n      var iv = forge.util.decode64(payload.iv);\n      var cipher = forge.util.decode64(payload.cipher);\n      var tag = payload.tag && forge.util.decode64(payload.tag); // Use RSA to decrypt AES key\n\n      var key = privateKey.decrypt(keyBytes, this.options.rsaStandard); // Create buffer and decipher\n\n      var buffer = forge.util.createBuffer(cipher);\n      var decipher = forge.cipher.createDecipher(this.options.aesStandard, key); // Actual decryption\n\n      decipher.start({\n        iv: iv,\n        tag: tag\n      });\n      decipher.update(buffer);\n      decipher.finish(); // Return utf-8 encoded bytes\n\n      var bytes = decipher.output.getBytes();\n      var decrypted = forge.util.decodeUtf8(bytes);\n      var output = {};\n      output.message = decrypted;\n      output.signature = payload.signature;\n      return output;\n    }\n    /**\n     * Validates encrypted message\n     *\n     * @param {String} encrypted Encrypted message\n     *\n     * @method\n     */\n\n  }, {\n    key: \"_validate\",\n    value: function _validate(encrypted) {\n      var p = JSON.parse(encrypted);\n      if ( // Check required properties\n      !(p.hasOwnProperty('v') && p.hasOwnProperty('iv') && p.hasOwnProperty('keys') && p.hasOwnProperty('cipher'))) throw 'Encrypted message is not valid';\n    }\n    /**\n     * Private function to add more entropy\n     *\n     * @param {String|Number} input Something random\n     *\n     * @method\n     */\n\n  }, {\n    key: \"_entropy\",\n    value: function _entropy(input) {\n      var inputString = String(input);\n      var bytes = forge.util.encodeUtf8(inputString);\n      forge.random.collect(bytes);\n    }\n  }]);\n\n  return Crypt;\n}();\n\nmodule.exports = Crypt;","map":null,"metadata":{},"sourceType":"script"}