{"ast":null,"code":"'use strict';\n\nmodule.exports = npa;\nmodule.exports.resolve = resolve;\nmodule.exports.Result = Result;\nlet url;\nlet HostedGit;\nlet semver;\nlet path_;\n\nfunction path() {\n  if (!path_) path_ = require('path');\n  return path_;\n}\n\nlet validatePackageName;\nlet osenv;\nconst isWindows = process.platform === 'win32' || global.FAKE_WINDOWS;\nconst hasSlashes = isWindows ? /\\\\|[/]/ : /[/]/;\nconst isURL = /^(?:git[+])?[a-z]+:/i;\nconst isFilename = /[.](?:tgz|tar.gz|tar)$/i;\n\nfunction npa(arg, where) {\n  let name;\n  let spec;\n\n  if (typeof arg === 'object') {\n    if (arg instanceof Result && (!where || where === arg.where)) {\n      return arg;\n    } else if (arg.name && arg.rawSpec) {\n      return npa.resolve(arg.name, arg.rawSpec, where || arg.where);\n    } else {\n      return npa(arg.raw, where || arg.where);\n    }\n  }\n\n  const nameEndsAt = arg[0] === '@' ? arg.slice(1).indexOf('@') + 1 : arg.indexOf('@');\n  const namePart = nameEndsAt > 0 ? arg.slice(0, nameEndsAt) : arg;\n\n  if (isURL.test(arg)) {\n    spec = arg;\n  } else if (namePart[0] !== '@' && (hasSlashes.test(namePart) || isFilename.test(namePart))) {\n    spec = arg;\n  } else if (nameEndsAt > 0) {\n    name = namePart;\n    spec = arg.slice(nameEndsAt + 1);\n  } else {\n    if (!validatePackageName) validatePackageName = require('validate-npm-package-name');\n    const valid = validatePackageName(arg);\n\n    if (valid.validForOldPackages) {\n      name = arg;\n    } else {\n      spec = arg;\n    }\n  }\n\n  return resolve(name, spec, where, arg);\n}\n\nconst isFilespec = isWindows ? /^(?:[.]|~[/]|[/\\\\]|[a-zA-Z]:)/ : /^(?:[.]|~[/]|[/]|[a-zA-Z]:)/;\n\nfunction resolve(name, spec, where, arg) {\n  const res = new Result({\n    raw: arg,\n    name: name,\n    rawSpec: spec,\n    fromArgument: arg != null\n  });\n  if (name) res.setName(name);\n\n  if (spec && (isFilespec.test(spec) || /^file:/i.test(spec))) {\n    return fromFile(res, where);\n  } else if (spec && /^npm:/i.test(spec)) {\n    return fromAlias(res, where);\n  }\n\n  if (!HostedGit) HostedGit = require('hosted-git-info');\n  const hosted = HostedGit.fromUrl(spec, {\n    noGitPlus: true,\n    noCommittish: true\n  });\n\n  if (hosted) {\n    return fromHostedGit(res, hosted);\n  } else if (spec && isURL.test(spec)) {\n    return fromURL(res);\n  } else if (spec && (hasSlashes.test(spec) || isFilename.test(spec))) {\n    return fromFile(res, where);\n  } else {\n    return fromRegistry(res);\n  }\n}\n\nfunction invalidPackageName(name, valid) {\n  const err = new Error(`Invalid package name \"${name}\": ${valid.errors.join('; ')}`);\n  err.code = 'EINVALIDPACKAGENAME';\n  return err;\n}\n\nfunction invalidTagName(name) {\n  const err = new Error(`Invalid tag name \"${name}\": Tags may not have any characters that encodeURIComponent encodes.`);\n  err.code = 'EINVALIDTAGNAME';\n  return err;\n}\n\nfunction Result(opts) {\n  this.type = opts.type;\n  this.registry = opts.registry;\n  this.where = opts.where;\n\n  if (opts.raw == null) {\n    this.raw = opts.name ? opts.name + '@' + opts.rawSpec : opts.rawSpec;\n  } else {\n    this.raw = opts.raw;\n  }\n\n  this.name = undefined;\n  this.escapedName = undefined;\n  this.scope = undefined;\n  this.rawSpec = opts.rawSpec == null ? '' : opts.rawSpec;\n  this.saveSpec = opts.saveSpec;\n  this.fetchSpec = opts.fetchSpec;\n  if (opts.name) this.setName(opts.name);\n  this.gitRange = opts.gitRange;\n  this.gitCommittish = opts.gitCommittish;\n  this.hosted = opts.hosted;\n}\n\nResult.prototype.setName = function (name) {\n  if (!validatePackageName) validatePackageName = require('validate-npm-package-name');\n  const valid = validatePackageName(name);\n\n  if (!valid.validForOldPackages) {\n    throw invalidPackageName(name, valid);\n  }\n\n  this.name = name;\n  this.scope = name[0] === '@' ? name.slice(0, name.indexOf('/')) : undefined; // scoped packages in couch must have slash url-encoded, e.g. @foo%2Fbar\n\n  this.escapedName = name.replace('/', '%2f');\n  return this;\n};\n\nResult.prototype.toString = function () {\n  const full = [];\n  if (this.name != null && this.name !== '') full.push(this.name);\n  const spec = this.saveSpec || this.fetchSpec || this.rawSpec;\n  if (spec != null && spec !== '') full.push(spec);\n  return full.length ? full.join('@') : this.raw;\n};\n\nResult.prototype.toJSON = function () {\n  const result = Object.assign({}, this);\n  delete result.hosted;\n  return result;\n};\n\nfunction setGitCommittish(res, committish) {\n  if (committish != null && committish.length >= 7 && committish.slice(0, 7) === 'semver:') {\n    res.gitRange = decodeURIComponent(committish.slice(7));\n    res.gitCommittish = null;\n  } else {\n    res.gitCommittish = committish === '' ? null : committish;\n  }\n\n  return res;\n}\n\nconst isAbsolutePath = /^[/]|^[A-Za-z]:/;\n\nfunction resolvePath(where, spec) {\n  if (isAbsolutePath.test(spec)) return spec;\n  return path().resolve(where, spec);\n}\n\nfunction isAbsolute(dir) {\n  if (dir[0] === '/') return true;\n  if (/^[A-Za-z]:/.test(dir)) return true;\n  return false;\n}\n\nfunction fromFile(res, where) {\n  if (!where) where = process.cwd();\n  res.type = isFilename.test(res.rawSpec) ? 'file' : 'directory';\n  res.where = where;\n  const spec = res.rawSpec.replace(/\\\\/g, '/').replace(/^file:[/]*([A-Za-z]:)/, '$1') // drive name paths on windows\n  .replace(/^file:(?:[/]*([~./]))?/, '$1');\n\n  if (/^~[/]/.test(spec)) {\n    // this is needed for windows and for file:~/foo/bar\n    if (!osenv) osenv = require('osenv');\n    res.fetchSpec = resolvePath(osenv.home(), spec.slice(2));\n    res.saveSpec = 'file:' + spec;\n  } else {\n    res.fetchSpec = resolvePath(where, spec);\n\n    if (isAbsolute(spec)) {\n      res.saveSpec = 'file:' + spec;\n    } else {\n      res.saveSpec = 'file:' + path().relative(where, res.fetchSpec);\n    }\n  }\n\n  return res;\n}\n\nfunction fromHostedGit(res, hosted) {\n  res.type = 'git';\n  res.hosted = hosted;\n  res.saveSpec = hosted.toString({\n    noGitPlus: false,\n    noCommittish: false\n  });\n  res.fetchSpec = hosted.getDefaultRepresentation() === 'shortcut' ? null : hosted.toString();\n  return setGitCommittish(res, hosted.committish);\n}\n\nfunction unsupportedURLType(protocol, spec) {\n  const err = new Error(`Unsupported URL Type \"${protocol}\": ${spec}`);\n  err.code = 'EUNSUPPORTEDPROTOCOL';\n  return err;\n}\n\nfunction matchGitScp(spec) {\n  // git ssh specifiers are overloaded to also use scp-style git\n  // specifiers, so we have to parse those out and treat them special.\n  // They are NOT true URIs, so we can't hand them to `url.parse`.\n  //\n  // This regex looks for things that look like:\n  // git+ssh://git@my.custom.git.com:username/project.git#deadbeef\n  //\n  // ...and various combinations. The username in the beginning is *required*.\n  const matched = spec.match(/^git\\+ssh:\\/\\/([^:#]+:[^#]+(?:\\.git)?)(?:#(.*))?$/i);\n  return matched && !matched[1].match(/:[0-9]+\\/?.*$/i) && {\n    fetchSpec: matched[1],\n    gitCommittish: matched[2] == null ? null : matched[2]\n  };\n}\n\nfunction fromURL(res) {\n  if (!url) url = require('url');\n  const urlparse = url.parse(res.rawSpec);\n  res.saveSpec = res.rawSpec; // check the protocol, and then see if it's git or not\n\n  switch (urlparse.protocol) {\n    case 'git:':\n    case 'git+http:':\n    case 'git+https:':\n    case 'git+rsync:':\n    case 'git+ftp:':\n    case 'git+file:':\n    case 'git+ssh:':\n      res.type = 'git';\n      const match = urlparse.protocol === 'git+ssh:' && matchGitScp(res.rawSpec);\n\n      if (match) {\n        setGitCommittish(res, match.gitCommittish);\n        res.fetchSpec = match.fetchSpec;\n      } else {\n        setGitCommittish(res, urlparse.hash != null ? urlparse.hash.slice(1) : '');\n        urlparse.protocol = urlparse.protocol.replace(/^git[+]/, '');\n\n        if (urlparse.protocol === 'file:' && /^git\\+file:\\/\\/[a-z]:/i.test(res.rawSpec)) {\n          // keep the drive letter : on windows file paths\n          urlparse.host += ':';\n          urlparse.hostname += ':';\n        }\n\n        delete urlparse.hash;\n        res.fetchSpec = url.format(urlparse);\n      }\n\n      break;\n\n    case 'http:':\n    case 'https:':\n      res.type = 'remote';\n      res.fetchSpec = res.saveSpec;\n      break;\n\n    default:\n      throw unsupportedURLType(urlparse.protocol, res.rawSpec);\n  }\n\n  return res;\n}\n\nfunction fromAlias(res, where) {\n  const subSpec = npa(res.rawSpec.substr(4), where);\n\n  if (subSpec.type === 'alias') {\n    throw new Error('nested aliases not supported');\n  }\n\n  if (!subSpec.registry) {\n    throw new Error('aliases only work for registry deps');\n  }\n\n  res.subSpec = subSpec;\n  res.registry = true;\n  res.type = 'alias';\n  res.saveSpec = null;\n  res.fetchSpec = null;\n  return res;\n}\n\nfunction fromRegistry(res) {\n  res.registry = true;\n  const spec = res.rawSpec === '' ? 'latest' : res.rawSpec; // no save spec for registry components as we save based on the fetched\n  // version, not on the argument so this can't compute that.\n\n  res.saveSpec = null;\n  res.fetchSpec = spec;\n  if (!semver) semver = require('semver');\n  const version = semver.valid(spec, true);\n  const range = semver.validRange(spec, true);\n\n  if (version) {\n    res.type = 'version';\n  } else if (range) {\n    res.type = 'range';\n  } else {\n    if (encodeURIComponent(spec) !== spec) {\n      throw invalidTagName(spec);\n    }\n\n    res.type = 'tag';\n  }\n\n  return res;\n}","map":null,"metadata":{},"sourceType":"script"}