{"ast":null,"code":"'use strict';\n\nlet Cache;\n\nconst url = require('url');\n\nconst CachePolicy = require('http-cache-semantics');\n\nconst fetch = require('node-fetch-npm');\n\nconst pkg = require('./package.json');\n\nconst retry = require('promise-retry');\n\nlet ssri;\n\nconst Stream = require('stream');\n\nconst getAgent = require('./agent');\n\nconst setWarning = require('./warning');\n\nconst isURL = /^https?:/;\nconst USER_AGENT = `${pkg.name}/${pkg.version} (+https://npm.im/${pkg.name})`;\nconst RETRY_ERRORS = ['ECONNRESET', // remote socket closed on us\n'ECONNREFUSED', // remote host refused to open connection\n'EADDRINUSE', // failed to bind to a local port (proxy?)\n'ETIMEDOUT' // someone in the transaction is WAY TOO SLOW\n// Known codes we do NOT retry on:\n// ENOTFOUND (getaddrinfo failure. Either bad hostname, or offline)\n];\nconst RETRY_TYPES = ['request-timeout']; // https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\n\nmodule.exports = cachingFetch;\n\ncachingFetch.defaults = function (_uri, _opts) {\n  const fetch = this;\n\n  if (typeof _uri === 'object') {\n    _opts = _uri;\n    _uri = null;\n  }\n\n  function defaultedFetch(uri, opts) {\n    const finalOpts = Object.assign({}, _opts || {}, opts || {});\n    return fetch(uri || _uri, finalOpts);\n  }\n\n  defaultedFetch.defaults = fetch.defaults;\n  defaultedFetch.delete = fetch.delete;\n  return defaultedFetch;\n};\n\ncachingFetch.delete = cacheDelete;\n\nfunction cacheDelete(uri, opts) {\n  opts = configureOptions(opts);\n\n  if (opts.cacheManager) {\n    const req = new fetch.Request(uri, {\n      method: opts.method,\n      headers: opts.headers\n    });\n    return opts.cacheManager.delete(req, opts);\n  }\n}\n\nfunction initializeCache(opts) {\n  if (typeof opts.cacheManager === 'string') {\n    if (!Cache) {\n      // Default cacache-based cache\n      Cache = require('./cache');\n    }\n\n    opts.cacheManager = new Cache(opts.cacheManager, opts);\n  }\n\n  opts.cache = opts.cache || 'default';\n\n  if (opts.cache === 'default' && isHeaderConditional(opts.headers)) {\n    // If header list contains `If-Modified-Since`, `If-None-Match`,\n    // `If-Unmodified-Since`, `If-Match`, or `If-Range`, fetch will set cache\n    // mode to \"no-store\" if it is \"default\".\n    opts.cache = 'no-store';\n  }\n}\n\nfunction configureOptions(_opts) {\n  const opts = Object.assign({}, _opts || {});\n  opts.method = (opts.method || 'GET').toUpperCase();\n\n  if (opts.retry && typeof opts.retry === 'number') {\n    opts.retry = {\n      retries: opts.retry\n    };\n  }\n\n  if (opts.retry === false) {\n    opts.retry = {\n      retries: 0\n    };\n  }\n\n  if (opts.cacheManager) {\n    initializeCache(opts);\n  }\n\n  return opts;\n}\n\nfunction initializeSsri() {\n  if (!ssri) {\n    ssri = require('ssri');\n  }\n}\n\nfunction cachingFetch(uri, _opts) {\n  const opts = configureOptions(_opts);\n\n  if (opts.integrity) {\n    initializeSsri(); // if verifying integrity, node-fetch must not decompress\n\n    opts.compress = false;\n  }\n\n  const isCachable = (opts.method === 'GET' || opts.method === 'HEAD') && opts.cacheManager && opts.cache !== 'no-store' && opts.cache !== 'reload';\n\n  if (isCachable) {\n    const req = new fetch.Request(uri, {\n      method: opts.method,\n      headers: opts.headers\n    });\n    return opts.cacheManager.match(req, opts).then(res => {\n      if (res) {\n        const warningCode = (res.headers.get('Warning') || '').match(/^\\d+/);\n\n        if (warningCode && +warningCode >= 100 && +warningCode < 200) {\n          // https://tools.ietf.org/html/rfc7234#section-4.3.4\n          //\n          // If a stored response is selected for update, the cache MUST:\n          //\n          // * delete any Warning header fields in the stored response with\n          //   warn-code 1xx (see Section 5.5);\n          //\n          // * retain any Warning header fields in the stored response with\n          //   warn-code 2xx;\n          //\n          res.headers.delete('Warning');\n        }\n\n        if (opts.cache === 'default' && !isStale(req, res)) {\n          return res;\n        }\n\n        if (opts.cache === 'default' || opts.cache === 'no-cache') {\n          return conditionalFetch(req, res, opts);\n        }\n\n        if (opts.cache === 'force-cache' || opts.cache === 'only-if-cached') {\n          //   112 Disconnected operation\n          // SHOULD be included if the cache is intentionally disconnected from\n          // the rest of the network for a period of time.\n          // (https://tools.ietf.org/html/rfc2616#section-14.46)\n          setWarning(res, 112, 'Disconnected operation');\n          return res;\n        }\n      }\n\n      if (!res && opts.cache === 'only-if-cached') {\n        const errorMsg = `request to ${uri} failed: cache mode is 'only-if-cached' but no cached response available.`;\n        const err = new Error(errorMsg);\n        err.code = 'ENOTCACHED';\n        throw err;\n      } // Missing cache entry, or mode is default (if stale), reload, no-store\n\n\n      return remoteFetch(req.url, opts);\n    });\n  }\n\n  return remoteFetch(uri, opts);\n}\n\nfunction iterableToObject(iter) {\n  const obj = {};\n\n  for (let k of iter.keys()) {\n    obj[k] = iter.get(k);\n  }\n\n  return obj;\n}\n\nfunction makePolicy(req, res) {\n  const _req = {\n    url: req.url,\n    method: req.method,\n    headers: iterableToObject(req.headers)\n  };\n  const _res = {\n    status: res.status,\n    headers: iterableToObject(res.headers)\n  };\n  return new CachePolicy(_req, _res, {\n    shared: false\n  });\n} // https://tools.ietf.org/html/rfc7234#section-4.2\n\n\nfunction isStale(req, res) {\n  if (!res) {\n    return null;\n  }\n\n  const _req = {\n    url: req.url,\n    method: req.method,\n    headers: iterableToObject(req.headers)\n  };\n  const policy = makePolicy(req, res);\n  const responseTime = res.headers.get('x-local-cache-time') || res.headers.get('date') || 0;\n  policy._responseTime = new Date(responseTime);\n  const bool = !policy.satisfiesWithoutRevalidation(_req);\n  return bool;\n}\n\nfunction mustRevalidate(res) {\n  return (res.headers.get('cache-control') || '').match(/must-revalidate/i);\n}\n\nfunction conditionalFetch(req, cachedRes, opts) {\n  const _req = {\n    url: req.url,\n    method: req.method,\n    headers: Object.assign({}, opts.headers || {})\n  };\n  const policy = makePolicy(req, cachedRes);\n  opts.headers = policy.revalidationHeaders(_req);\n  return remoteFetch(req.url, opts).then(condRes => {\n    const revalidatedPolicy = policy.revalidatedPolicy(_req, {\n      status: condRes.status,\n      headers: iterableToObject(condRes.headers)\n    });\n\n    if (condRes.status >= 500 && !mustRevalidate(cachedRes)) {\n      //   111 Revalidation failed\n      // MUST be included if a cache returns a stale response because an\n      // attempt to revalidate the response failed, due to an inability to\n      // reach the server.\n      // (https://tools.ietf.org/html/rfc2616#section-14.46)\n      setWarning(cachedRes, 111, 'Revalidation failed');\n      return cachedRes;\n    }\n\n    if (condRes.status === 304) {\n      // 304 Not Modified\n      condRes.body = cachedRes.body;\n      return opts.cacheManager.put(req, condRes, opts).then(newRes => {\n        newRes.headers = new fetch.Headers(revalidatedPolicy.policy.responseHeaders());\n        return newRes;\n      });\n    }\n\n    return condRes;\n  }).then(res => res).catch(err => {\n    if (mustRevalidate(cachedRes)) {\n      throw err;\n    } else {\n      //   111 Revalidation failed\n      // MUST be included if a cache returns a stale response because an\n      // attempt to revalidate the response failed, due to an inability to\n      // reach the server.\n      // (https://tools.ietf.org/html/rfc2616#section-14.46)\n      setWarning(cachedRes, 111, 'Revalidation failed'); //   199 Miscellaneous warning\n      // The warning text MAY include arbitrary information to be presented to\n      // a human user, or logged. A system receiving this warning MUST NOT take\n      // any automated action, besides presenting the warning to the user.\n      // (https://tools.ietf.org/html/rfc2616#section-14.46)\n\n      setWarning(cachedRes, 199, `Miscellaneous Warning ${err.code}: ${err.message}`);\n      return cachedRes;\n    }\n  });\n}\n\nfunction remoteFetchHandleIntegrity(res, integrity) {\n  const oldBod = res.body;\n  const newBod = ssri.integrityStream({\n    integrity\n  });\n  oldBod.pipe(newBod);\n  res.body = newBod;\n  oldBod.once('error', err => {\n    newBod.emit('error', err);\n  });\n  newBod.once('error', err => {\n    oldBod.emit('error', err);\n  });\n}\n\nfunction remoteFetch(uri, opts) {\n  const agent = getAgent(uri, opts);\n  const headers = Object.assign({\n    'connection': agent ? 'keep-alive' : 'close',\n    'user-agent': USER_AGENT\n  }, opts.headers || {});\n  const reqOpts = {\n    agent,\n    body: opts.body,\n    compress: opts.compress,\n    follow: opts.follow,\n    headers: new fetch.Headers(headers),\n    method: opts.method,\n    redirect: 'manual',\n    size: opts.size,\n    counter: opts.counter,\n    timeout: opts.timeout\n  };\n  return retry((retryHandler, attemptNum) => {\n    const req = new fetch.Request(uri, reqOpts);\n    return fetch(req).then(res => {\n      res.headers.set('x-fetch-attempts', attemptNum);\n\n      if (opts.integrity) {\n        remoteFetchHandleIntegrity(res, opts.integrity);\n      }\n\n      const isStream = req.body instanceof Stream;\n\n      if (opts.cacheManager) {\n        const isMethodGetHead = req.method === 'GET' || req.method === 'HEAD';\n        const isCachable = opts.cache !== 'no-store' && isMethodGetHead && makePolicy(req, res).storable() && res.status === 200; // No other statuses should be stored!\n\n        if (isCachable) {\n          return opts.cacheManager.put(req, res, opts);\n        }\n\n        if (!isMethodGetHead) {\n          return opts.cacheManager.delete(req).then(() => {\n            if (res.status >= 500 && req.method !== 'POST' && !isStream) {\n              if (typeof opts.onRetry === 'function') {\n                opts.onRetry(res);\n              }\n\n              return retryHandler(res);\n            }\n\n            return res;\n          });\n        }\n      }\n\n      const isRetriable = req.method !== 'POST' && !isStream && (res.status === 408 || // Request Timeout\n      res.status === 420 || // Enhance Your Calm (usually Twitter rate-limit)\n      res.status === 429 || // Too Many Requests (\"standard\" rate-limiting)\n      res.status >= 500 // Assume server errors are momentary hiccups\n      );\n\n      if (isRetriable) {\n        if (typeof opts.onRetry === 'function') {\n          opts.onRetry(res);\n        }\n\n        return retryHandler(res);\n      }\n\n      if (!fetch.isRedirect(res.status) || opts.redirect === 'manual') {\n        return res;\n      } // handle redirects - matches behavior of npm-fetch: https://github.com/bitinn/node-fetch\n\n\n      if (opts.redirect === 'error') {\n        const err = new Error(`redirect mode is set to error: ${uri}`);\n        err.code = 'ENOREDIRECT';\n        throw err;\n      }\n\n      if (!res.headers.get('location')) {\n        const err = new Error(`redirect location header missing at: ${uri}`);\n        err.code = 'EINVALIDREDIRECT';\n        throw err;\n      }\n\n      if (req.counter >= req.follow) {\n        const err = new Error(`maximum redirect reached at: ${uri}`);\n        err.code = 'EMAXREDIRECT';\n        throw err;\n      }\n\n      const resolvedUrl = url.resolve(req.url, res.headers.get('location'));\n      let redirectURL = url.parse(resolvedUrl);\n\n      if (isURL.test(res.headers.get('location'))) {\n        redirectURL = url.parse(res.headers.get('location'));\n      } // Remove authorization if changing hostnames (but not if just\n      // changing ports or protocols).  This matches the behavior of request:\n      // https://github.com/request/request/blob/b12a6245/lib/redirect.js#L134-L138\n\n\n      if (url.parse(req.url).hostname !== redirectURL.hostname) {\n        req.headers.delete('authorization');\n      } // for POST request with 301/302 response, or any request with 303 response,\n      // use GET when following redirect\n\n\n      if (res.status === 303 || (res.status === 301 || res.status === 302) && req.method === 'POST') {\n        opts.method = 'GET';\n        opts.body = null;\n        req.headers.delete('content-length');\n      }\n\n      opts.headers = {};\n      req.headers.forEach((value, name) => {\n        opts.headers[name] = value;\n      });\n      opts.counter = ++req.counter;\n      return cachingFetch(resolvedUrl, opts);\n    }).catch(err => {\n      const code = err.code === 'EPROMISERETRY' ? err.retried.code : err.code;\n      const isRetryError = RETRY_ERRORS.indexOf(code) === -1 && RETRY_TYPES.indexOf(err.type) === -1;\n\n      if (req.method === 'POST' || isRetryError) {\n        throw err;\n      }\n\n      if (typeof opts.onRetry === 'function') {\n        opts.onRetry(err);\n      }\n\n      return retryHandler(err);\n    });\n  }, opts.retry).catch(err => {\n    if (err.status >= 400) {\n      return err;\n    }\n\n    throw err;\n  });\n}\n\nfunction isHeaderConditional(headers) {\n  if (!headers || typeof headers !== 'object') {\n    return false;\n  }\n\n  const modifiers = ['if-modified-since', 'if-none-match', 'if-unmodified-since', 'if-match', 'if-range'];\n  return Object.keys(headers).some(h => modifiers.indexOf(h.toLowerCase()) !== -1);\n}","map":null,"metadata":{},"sourceType":"script"}