{"ast":null,"code":"import { File } from 'better-xlsx';\nimport { saveAs } from 'file-saver';\nexport function TableDownload(column, dataSource, fileName) {\n  //  new working spectrum \n  const file = new File(); //  the new table \n\n  let sheet = file.addSheet('sheet-test'); //  gets the number of header rows \n\n  let depth = getDepth(column); //  gets the number of columns in the header \n\n  let columnNum = getColumns(column); //  new number of header rows \n\n  let rowArr = [];\n\n  for (let k = 0; k < depth; k++) {\n    rowArr.push(sheet.addRow());\n  } //  populate the cells according to the number of columns \n\n\n  rowArr.map(ele => {\n    for (let j = 0; j < columnNum; j++) {\n      let cell = ele.addCell();\n      cell.value = j;\n    }\n  }); //  initializes the header \n\n  init(column, 0, 0); //  unfold the columns in order \n\n  let columnLineArr = [];\n  columnLine(column); //  according to the column, the dataSource the data inside is sorted and converted into a two-dimensional array \n\n  let dataSourceArr = [];\n  dataSource.map(ele => {\n    let dataTemp = [];\n    columnLineArr.map(item => {\n      dataTemp.push({\n        [item.dataIndex]: ele[item.dataIndex],\n        value: ele[item.dataIndex]\n      });\n    });\n    dataSourceArr.push(dataTemp);\n  }); // debugger;\n  //  drawing table data \n\n  dataSourceArr.forEach((item, index) => {\n    // according to the data, create the corresponding number of rows \n    let row = sheet.addRow();\n    row.setHeightCM(0.8); // creates a cell for that number \n\n    item.map(ele => {\n      let cell = row.addCell();\n\n      if (ele.hasOwnProperty('num')) {\n        cell.value = index + 1;\n      } else {\n        cell.value = ele.value;\n      }\n\n      cell.style.align.v = 'center';\n      cell.style.align.h = 'center';\n    });\n  }); // set the width of each column \n\n  for (var i = 0; i < 4; i++) {\n    sheet.col(i).width = 20;\n  }\n\n  file.saveAs('blob').then(function (content) {\n    saveAs(content, fileName + '.xlsx');\n  }); //  unfold the columns in order \n\n  function columnLine(column) {\n    column.map(ele => {\n      if (ele.children === undefined || ele.children.length === 0) {\n        columnLineArr.push(ele);\n      } else {\n        columnLine(ele.children);\n      }\n    });\n  } //  initializes the header \n\n\n  function init(column, rowIndex, columnIndex) {\n    column.map((item, index) => {\n      let hCell = sheet.cell(rowIndex, columnIndex); //  if there are no child elements,   all the columns \n\n      if (item.title === ' operation ') {\n        hCell.value = '';\n        return;\n      } else if (item.children === undefined || item.children.length === 0) {\n        //  add a cell to the first row \n        hCell.value = item.title;\n        hCell.vMerge = depth - rowIndex - 1;\n        hCell.style.align.h = 'center';\n        hCell.style.align.v = 'center';\n        columnIndex++; // rowIndex++\n      } else {\n        let childrenNum = 0;\n\n        function getColumns(arr) {\n          arr.map(ele => {\n            if (ele.children) {\n              getColumns(ele.children);\n            } else {\n              childrenNum++;\n            }\n          });\n        }\n\n        getColumns(item.children);\n        hCell.hMerge = childrenNum - 1;\n        hCell.value = item.title;\n        hCell.style.align.h = 'center';\n        hCell.style.align.v = 'center';\n        let rowCopy = rowIndex;\n        rowCopy++;\n        init(item.children, rowCopy, columnIndex); //  next cell start \n\n        columnIndex = columnIndex + childrenNum;\n      }\n    });\n  } //  gets table head rows \n\n\n  function getDepth(arr) {\n    const eleDepths = [];\n    arr.forEach(ele => {\n      let depth = 0;\n\n      if (Array.isArray(ele.children)) {\n        depth = getDepth(ele.children);\n      }\n\n      eleDepths.push(depth);\n    });\n    return 1 + max(eleDepths);\n  }\n\n  function max(arr) {\n    return arr.reduce((accu, curr) => {\n      if (curr > accu) return curr;\n      return accu;\n    });\n  } //  calculates the number of header columns \n\n\n  function getColumns(arr) {\n    let columnNum = 0;\n    arr.map(ele => {\n      if (ele.children) {\n        getColumns(ele.children);\n      } else {\n        columnNum++;\n      }\n    });\n    return columnNum;\n  }\n}","map":{"version":3,"sources":["/Users/dhruvaagrawal/Desktop/Work/Spocto/CMS/app/src/constants/TableDownload.js"],"names":["File","saveAs","TableDownload","column","dataSource","fileName","file","sheet","addSheet","depth","getDepth","columnNum","getColumns","rowArr","k","push","addRow","map","ele","j","cell","addCell","value","init","columnLineArr","columnLine","dataSourceArr","dataTemp","item","dataIndex","forEach","index","row","setHeightCM","hasOwnProperty","style","align","v","h","i","col","width","then","content","children","undefined","length","rowIndex","columnIndex","hCell","title","vMerge","childrenNum","arr","hMerge","rowCopy","eleDepths","Array","isArray","max","reduce","accu","curr"],"mappings":"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","sourcesContent":["import { File } from 'better-xlsx';\nimport { saveAs } from 'file-saver';\n\nexport function TableDownload(column, dataSource, fileName) {\n\n    //  new working spectrum \n    const file = new File();\n    //  the new table \n    let sheet = file.addSheet('sheet-test');\n    //  gets the number of header rows \n    let depth = getDepth(column);\n    //  gets the number of columns in the header \n    let columnNum = getColumns(column);\n    //  new number of header rows \n    let rowArr = [];\n    for (let k = 0; k < depth; k++) {\n        rowArr.push(sheet.addRow());\n    }\n    //  populate the cells according to the number of columns \n    rowArr.map(ele => {\n        for (let j = 0; j < columnNum; j++) {\n            let cell = ele.addCell();\n            cell.value = j;\n        }\n    });\n\n    //  initializes the header \n    init(column, 0, 0);\n    //  unfold the columns in order \n    let columnLineArr = [];\n    columnLine(column);\n    //  according to the column, the dataSource the data inside is sorted and converted into a two-dimensional array \n    let dataSourceArr = [];\n    dataSource.map(ele => {\n        let dataTemp = [];\n        columnLineArr.map(item => {\n        dataTemp.push({\n            [item.dataIndex]: ele[item.dataIndex],\n            value: ele[item.dataIndex],\n        });\n        });\n        dataSourceArr.push(dataTemp);\n    });\n    // debugger;\n    //  drawing table data \n    dataSourceArr.forEach((item, index) => {\n        // according to the data, create the corresponding number of rows \n        let row = sheet.addRow();\n        row.setHeightCM(0.8);\n        // creates a cell for that number \n        item.map(ele => {\n        let cell = row.addCell();\n        if (ele.hasOwnProperty('num')) {\n            cell.value = index + 1;\n        } else {\n            cell.value = ele.value;\n        }\n        cell.style.align.v = 'center';\n        cell.style.align.h = 'center';\n        });\n    });\n    // set the width of each column \n    for (var i = 0; i < 4; i++) {\n        sheet.col(i).width = 20;\n    }\n    file.saveAs('blob').then(function(content) {\n        saveAs(content, fileName + '.xlsx');\n    });\n\n    //  unfold the columns in order \n    function columnLine(column) {\n        column.map(ele => {\n        if (ele.children === undefined || ele.children.length === 0) {\n            columnLineArr.push(ele);\n        } else {\n            columnLine(ele.children);\n        }\n        });\n    }\n\n    //  initializes the header \n    function init(column, rowIndex, columnIndex) {\n        column.map((item, index) => {\n        let hCell = sheet.cell(rowIndex, columnIndex);\n        //  if there are no child elements,   all the columns \n        if (item.title === ' operation ') {\n            hCell.value = '';\n            return;\n        } else if (item.children === undefined || item.children.length === 0) {\n            //  add a cell to the first row \n            hCell.value = item.title;\n            hCell.vMerge = depth - rowIndex - 1;\n            hCell.style.align.h = 'center';\n            hCell.style.align.v = 'center';\n            columnIndex++;\n            // rowIndex++\n        } else {\n            let childrenNum = 0;\n            function getColumns(arr) {\n            arr.map(ele => {\n                if (ele.children) {\n                getColumns(ele.children);\n                } else {\n                childrenNum++;\n                }\n            });\n            }\n            getColumns(item.children);\n            hCell.hMerge = childrenNum - 1;\n            hCell.value = item.title;\n            hCell.style.align.h = 'center';\n            hCell.style.align.v = 'center';\n            let rowCopy = rowIndex;\n            rowCopy++;\n            init(item.children, rowCopy, columnIndex);\n            //  next cell start \n            columnIndex = columnIndex + childrenNum;\n        }\n        });\n    }\n\n    //  gets table head rows \n    function getDepth(arr) {\n        const eleDepths = [];\n        arr.forEach(ele => {\n        let depth = 0;\n        if (Array.isArray(ele.children)) {\n            depth = getDepth(ele.children);\n        }\n        eleDepths.push(depth);\n        });\n        return 1 + max(eleDepths);\n    }\n\n    function max(arr) {\n        return arr.reduce((accu, curr) => {\n        if (curr > accu) return curr;\n        return accu;\n        });\n    }\n    //  calculates the number of header columns \n    function getColumns(arr) {\n        let columnNum = 0;\n        arr.map(ele => {\n        if (ele.children) {\n            getColumns(ele.children);\n        } else {\n            columnNum++;\n        }\n        });\n        return columnNum;\n    }\n\n}"]},"metadata":{},"sourceType":"module"}