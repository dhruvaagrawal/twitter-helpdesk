{"ast":null,"code":"'use strict'; // calls linkIfExists on unix, or cmdShimIfExists on Windows\n// reads the cmd shim to ensure it's where we need it to be in the case of\n// top level global packages\n\nconst readCmdShim = require('read-cmd-shim');\n\nconst cmdShim = require('cmd-shim');\n\nconst {\n  linkIfExists\n} = require('./link.js');\n\nconst binLink = (from, to, opts, cb) => {\n  // just for testing\n  const platform = opts._FAKE_PLATFORM_ || process.platform;\n\n  if (platform !== 'win32') {\n    return linkIfExists(from, to, opts, cb);\n  }\n\n  if (!opts.clobberLinkGently || opts.force === true || !opts.gently || typeof opts.gently !== 'string') {\n    // easy, just go ahead and delete anything in the way\n    return cmdShim.ifExists(from, to, cb);\n  } // read all three shim targets\n  // if any exist, and are not a shim to our gently folder, then\n  // exit with a simulated EEXIST error.\n\n\n  const shimFiles = [to, to + '.cmd', to + '.ps1']; // call this once we've checked all three, if we're good\n\n  const done = () => cmdShim.ifExists(from, to, cb);\n\n  const then = times(3, done, cb);\n  shimFiles.forEach(to => isClobberable(from, to, opts, then));\n};\n\nconst times = (n, ok, cb) => {\n  let errState = null;\n  return er => {\n    if (!errState) {\n      if (er) {\n        cb(errState = er);\n      } else if (--n === 0) {\n        ok();\n      }\n    }\n  };\n};\n\nconst isClobberable = (from, to, opts, cb) => {\n  readCmdShim(to, (er, target) => {\n    // either going to get an error, or the target of where this\n    // cmd shim points.\n    // shim, not in opts.gently: simulate EEXIST\n    // not a shim: simulate EEXIST\n    // ENOENT: fine, move forward\n    // shim in opts.gently: fine\n    if (er) {\n      switch (er.code) {\n        case 'ENOENT':\n          // totally fine, nothing there to clobber\n          return cb();\n\n        case 'ENOTASHIM':\n          // something is there, and it's not one of ours\n          return cb(simulateEEXIST(from, to));\n\n        default:\n          // would probably fail this way later anyway\n          // can't read the file, likely can't write it either\n          return cb(er);\n      }\n    } // no error, check the target\n\n\n    if (target.indexOf(opts.gently) !== 0) {\n      return cb(simulateEEXIST(from, to));\n    } // ok!  it's one of ours.\n\n\n    return cb();\n  });\n};\n\nconst simulateEEXIST = (from, to) => {\n  // simulate the EEXIST we'd get from fs.symlink to the file\n  const err = new Error('EEXIST: file already exists, cmd shim \\'' + from + '\\' -> \\'' + to + '\\'');\n  err.code = 'EEXIST';\n  err.path = from;\n  err.dest = to;\n  return err;\n};\n\nmodule.exports = binLink;","map":null,"metadata":{},"sourceType":"script"}