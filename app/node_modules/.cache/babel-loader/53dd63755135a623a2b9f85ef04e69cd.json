{"ast":null,"code":"export default function TableDownload(column, dataSource, fileName) {\n  //  new working spectrum \n  const file = new File(); //  the new table \n\n  let sheet = file.addSheet('sheet-test'); //  gets the number of header rows \n\n  let depth = getDepth(column); //  gets the number of columns in the header \n\n  let columnNum = getColumns(column); //  new number of header rows \n\n  let rowArr = [];\n\n  for (let k = 0; k < depth; k++) {\n    rowArr.push(sheet.addRow());\n  } //  populate the cells according to the number of columns \n\n\n  rowArr.map(ele => {\n    for (let j = 0; j < columnNum; j++) {\n      let cell = ele.addCell();\n      cell.value = j;\n    }\n  }); //  initializes the header \n\n  init(column, 0, 0); //  unfold the columns in order \n\n  let columnLineArr = [];\n  columnLine(column); //  according to the column, the dataSource the data inside is sorted and converted into a two-dimensional array \n\n  let dataSourceArr = [];\n  dataSource.map(ele => {\n    let dataTemp = [];\n    columnLineArr.map(item => {\n      dataTemp.push({\n        [item.dataIndex]: ele[item.dataIndex],\n        value: ele[item.dataIndex]\n      });\n    });\n    dataSourceArr.push(dataTemp);\n  }); // debugger;\n  //  drawing table data \n\n  dataSourceArr.forEach((item, index) => {\n    // according to the data, create the corresponding number of rows \n    let row = sheet.addRow();\n    row.setHeightCM(0.8); // creates a cell for that number \n\n    item.map(ele => {\n      let cell = row.addCell();\n\n      if (ele.hasOwnProperty('num')) {\n        cell.value = index + 1;\n      } else {\n        cell.value = ele.value;\n      }\n\n      cell.style.align.v = 'center';\n      cell.style.align.h = 'center';\n    });\n  }); // set the width of each column \n\n  for (var i = 0; i < 4; i++) {\n    sheet.col(i).width = 20;\n  }\n\n  file.saveAs('blob').then(function (content) {\n    saveAs(content, fileName + '.xlsx');\n  }); //  unfold the columns in order \n\n  function columnLine(column) {\n    column.map(ele => {\n      if (ele.children === undefined || ele.children.length === 0) {\n        columnLineArr.push(ele);\n      } else {\n        columnLine(ele.children);\n      }\n    });\n  } //  initializes the header \n\n\n  function init(column, rowIndex, columnIndex) {\n    column.map((item, index) => {\n      let hCell = sheet.cell(rowIndex, columnIndex); //  if there are no child elements,   all the columns \n\n      if (item.title === ' operation ') {\n        hCell.value = '';\n        return;\n      } else if (item.children === undefined || item.children.length === 0) {\n        //  add a cell to the first row \n        hCell.value = item.title;\n        hCell.vMerge = depth - rowIndex - 1;\n        hCell.style.align.h = 'center';\n        hCell.style.align.v = 'center';\n        columnIndex++; // rowIndex++\n      } else {\n        let childrenNum = 0;\n\n        function getColumns(arr) {\n          arr.map(ele => {\n            if (ele.children) {\n              getColumns(ele.children);\n            } else {\n              childrenNum++;\n            }\n          });\n        }\n\n        getColumns(item.children);\n        hCell.hMerge = childrenNum - 1;\n        hCell.value = item.title;\n        hCell.style.align.h = 'center';\n        hCell.style.align.v = 'center';\n        let rowCopy = rowIndex;\n        rowCopy++;\n        init(item.children, rowCopy, columnIndex); //  next cell start \n\n        columnIndex = columnIndex + childrenNum;\n      }\n    });\n  } //  gets table head rows \n\n\n  function getDepth(arr) {\n    const eleDepths = [];\n    arr.forEach(ele => {\n      let depth = 0;\n\n      if (Array.isArray(ele.children)) {\n        depth = getDepth(ele.children);\n      }\n\n      eleDepths.push(depth);\n    });\n    return 1 + max(eleDepths);\n  }\n\n  function max(arr) {\n    return arr.reduce((accu, curr) => {\n      if (curr > accu) return curr;\n      return accu;\n    });\n  } //  calculates the number of header columns \n\n\n  function getColumns(arr) {\n    let columnNum = 0;\n    arr.map(ele => {\n      if (ele.children) {\n        getColumns(ele.children);\n      } else {\n        columnNum++;\n      }\n    });\n    return columnNum;\n  }\n}","map":{"version":3,"sources":["/Users/dhruvaagrawal/Desktop/Work/Spocto/CMS/app/src/constants/TableDownload.js"],"names":["TableDownload","column","dataSource","fileName","file","File","sheet","addSheet","depth","getDepth","columnNum","getColumns","rowArr","k","push","addRow","map","ele","j","cell","addCell","value","init","columnLineArr","columnLine","dataSourceArr","dataTemp","item","dataIndex","forEach","index","row","setHeightCM","hasOwnProperty","style","align","v","h","i","col","width","saveAs","then","content","children","undefined","length","rowIndex","columnIndex","hCell","title","vMerge","childrenNum","arr","hMerge","rowCopy","eleDepths","Array","isArray","max","reduce","accu","curr"],"mappings":"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","sourcesContent":["export default function TableDownload(column, dataSource, fileName) {\n\n    //  new working spectrum \n    const file = new File();\n    //  the new table \n    let sheet = file.addSheet('sheet-test');\n    //  gets the number of header rows \n    let depth = getDepth(column);\n    //  gets the number of columns in the header \n    let columnNum = getColumns(column);\n    //  new number of header rows \n    let rowArr = [];\n    for (let k = 0; k < depth; k++) {\n        rowArr.push(sheet.addRow());\n    }\n    //  populate the cells according to the number of columns \n    rowArr.map(ele => {\n        for (let j = 0; j < columnNum; j++) {\n        let cell = ele.addCell();\n        cell.value = j;\n        }\n    });\n\n    //  initializes the header \n    init(column, 0, 0);\n    //  unfold the columns in order \n    let columnLineArr = [];\n    columnLine(column);\n    //  according to the column, the dataSource the data inside is sorted and converted into a two-dimensional array \n    let dataSourceArr = [];\n    dataSource.map(ele => {\n        let dataTemp = [];\n        columnLineArr.map(item => {\n        dataTemp.push({\n            [item.dataIndex]: ele[item.dataIndex],\n            value: ele[item.dataIndex],\n        });\n        });\n        dataSourceArr.push(dataTemp);\n    });\n    // debugger;\n    //  drawing table data \n    dataSourceArr.forEach((item, index) => {\n        // according to the data, create the corresponding number of rows \n        let row = sheet.addRow();\n        row.setHeightCM(0.8);\n        // creates a cell for that number \n        item.map(ele => {\n        let cell = row.addCell();\n        if (ele.hasOwnProperty('num')) {\n            cell.value = index + 1;\n        } else {\n            cell.value = ele.value;\n        }\n        cell.style.align.v = 'center';\n        cell.style.align.h = 'center';\n        });\n    });\n    // set the width of each column \n    for (var i = 0; i < 4; i++) {\n        sheet.col(i).width = 20;\n    }\n    file.saveAs('blob').then(function(content) {\n        saveAs(content, fileName + '.xlsx');\n    });\n\n    //  unfold the columns in order \n    function columnLine(column) {\n        column.map(ele => {\n        if (ele.children === undefined || ele.children.length === 0) {\n            columnLineArr.push(ele);\n        } else {\n            columnLine(ele.children);\n        }\n        });\n    }\n\n    //  initializes the header \n    function init(column, rowIndex, columnIndex) {\n        column.map((item, index) => {\n        let hCell = sheet.cell(rowIndex, columnIndex);\n        //  if there are no child elements,   all the columns \n        if (item.title === ' operation ') {\n            hCell.value = '';\n            return;\n        } else if (item.children === undefined || item.children.length === 0) {\n            //  add a cell to the first row \n            hCell.value = item.title;\n            hCell.vMerge = depth - rowIndex - 1;\n            hCell.style.align.h = 'center';\n            hCell.style.align.v = 'center';\n            columnIndex++;\n            // rowIndex++\n        } else {\n            let childrenNum = 0;\n            function getColumns(arr) {\n            arr.map(ele => {\n                if (ele.children) {\n                getColumns(ele.children);\n                } else {\n                childrenNum++;\n                }\n            });\n            }\n            getColumns(item.children);\n            hCell.hMerge = childrenNum - 1;\n            hCell.value = item.title;\n            hCell.style.align.h = 'center';\n            hCell.style.align.v = 'center';\n            let rowCopy = rowIndex;\n            rowCopy++;\n            init(item.children, rowCopy, columnIndex);\n            //  next cell start \n            columnIndex = columnIndex + childrenNum;\n        }\n        });\n    }\n\n    //  gets table head rows \n    function getDepth(arr) {\n        const eleDepths = [];\n        arr.forEach(ele => {\n        let depth = 0;\n        if (Array.isArray(ele.children)) {\n            depth = getDepth(ele.children);\n        }\n        eleDepths.push(depth);\n        });\n        return 1 + max(eleDepths);\n    }\n\n    function max(arr) {\n        return arr.reduce((accu, curr) => {\n        if (curr > accu) return curr;\n        return accu;\n        });\n    }\n    //  calculates the number of header columns \n    function getColumns(arr) {\n        let columnNum = 0;\n        arr.map(ele => {\n        if (ele.children) {\n            getColumns(ele.children);\n        } else {\n            columnNum++;\n        }\n        });\n        return columnNum;\n    }\n\n}"]},"metadata":{},"sourceType":"module"}