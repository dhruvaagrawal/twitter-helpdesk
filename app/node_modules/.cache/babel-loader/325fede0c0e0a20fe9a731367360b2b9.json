{"ast":null,"code":"// XXX use infer-owner or gentle-fs.mkdir here\nconst npm = require('../npm.js');\n\nconst path = require('path');\n\nconst chownr = require('chownr');\n\nconst writeFileAtomic = require('write-file-atomic');\n\nconst mkdirp = require('mkdirp');\n\nconst fs = require('graceful-fs');\n\nlet cache = null;\nlet cacheUid = null;\nlet cacheGid = null;\nlet needChown = typeof process.getuid === 'function';\n\nconst getCacheOwner = () => {\n  let st;\n\n  try {\n    st = fs.lstatSync(cache);\n  } catch (er) {\n    if (er.code !== 'ENOENT') {\n      throw er;\n    }\n\n    st = fs.lstatSync(path.dirname(cache));\n  }\n\n  cacheUid = st.uid;\n  cacheGid = st.gid;\n  needChown = st.uid !== process.getuid() || st.gid !== process.getgid();\n};\n\nconst writeOrAppend = (method, file, data) => {\n  if (!cache) {\n    cache = npm.config.get('cache');\n  } // redundant if already absolute, but prevents non-absolute files\n  // from being written as if they're part of the cache.\n\n\n  file = path.resolve(cache, file);\n\n  if (cacheUid === null && needChown) {\n    getCacheOwner();\n  }\n\n  const dir = path.dirname(file);\n  const firstMade = mkdirp.sync(dir);\n\n  if (!needChown) {\n    return method(file, data);\n  }\n\n  let methodThrew = true;\n\n  try {\n    method(file, data);\n    methodThrew = false;\n  } finally {\n    // always try to leave it in the right ownership state, even on failure\n    // let the method error fail it instead of the chownr error, though\n    if (!methodThrew) {\n      chownr.sync(firstMade || file, cacheUid, cacheGid);\n    } else {\n      try {\n        chownr.sync(firstMade || file, cacheUid, cacheGid);\n      } catch (_) {}\n    }\n  }\n};\n\nexports.append = (file, data) => writeOrAppend(fs.appendFileSync, file, data);\n\nexports.write = (file, data) => writeOrAppend(writeFileAtomic.sync, file, data);","map":null,"metadata":{},"sourceType":"script"}