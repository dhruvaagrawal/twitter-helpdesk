{"ast":null,"code":"'use strict';\n/**\n * index.js\n *\n * a request API compatible with window.fetch\n */\n\nconst url = require('url');\n\nconst http = require('http');\n\nconst https = require('https');\n\nconst zlib = require('zlib');\n\nconst PassThrough = require('stream').PassThrough;\n\nconst Body = require('./body.js');\n\nconst writeToStream = Body.writeToStream;\n\nconst Response = require('./response');\n\nconst Headers = require('./headers');\n\nconst Request = require('./request');\n\nconst getNodeRequestOptions = Request.getNodeRequestOptions;\n\nconst FetchError = require('./fetch-error');\n\nconst isURL = /^https?:/;\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */\n\nexports = module.exports = fetch;\n\nfunction fetch(uri, opts) {\n  // allow custom promise\n  if (!fetch.Promise) {\n    throw new Error('native promise missing, set fetch.Promise to your favorite alternative');\n  }\n\n  Body.Promise = fetch.Promise; // wrap http.request into fetch\n\n  return new fetch.Promise((resolve, reject) => {\n    // build request object\n    const request = new Request(uri, opts);\n    const options = getNodeRequestOptions(request);\n    const send = (options.protocol === 'https:' ? https : http).request; // http.request only support string as host header, this hack make custom host header possible\n\n    if (options.headers.host) {\n      options.headers.host = options.headers.host[0];\n    } // send request\n\n\n    const req = send(options);\n    let reqTimeout;\n\n    if (request.timeout) {\n      req.once('socket', socket => {\n        reqTimeout = setTimeout(() => {\n          req.abort();\n          reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));\n        }, request.timeout);\n      });\n    }\n\n    req.on('error', err => {\n      clearTimeout(reqTimeout);\n      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));\n    });\n    req.on('response', res => {\n      clearTimeout(reqTimeout); // handle redirect\n\n      if (fetch.isRedirect(res.statusCode) && request.redirect !== 'manual') {\n        if (request.redirect === 'error') {\n          reject(new FetchError(`redirect mode is set to error: ${request.url}`, 'no-redirect'));\n          return;\n        }\n\n        if (request.counter >= request.follow) {\n          reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n          return;\n        }\n\n        if (!res.headers.location) {\n          reject(new FetchError(`redirect location header missing at: ${request.url}`, 'invalid-redirect'));\n          return;\n        } // Remove authorization if changing hostnames (but not if just\n        // changing ports or protocols).  This matches the behavior of request:\n        // https://github.com/request/request/blob/b12a6245/lib/redirect.js#L134-L138\n\n\n        const resolvedUrl = url.resolve(request.url, res.headers.location);\n        let redirectURL = '';\n\n        if (!isURL.test(res.headers.location)) {\n          redirectURL = url.parse(resolvedUrl);\n        } else {\n          redirectURL = url.parse(res.headers.location);\n        }\n\n        if (url.parse(request.url).hostname !== redirectURL.hostname) {\n          request.headers.delete('authorization');\n        } // per fetch spec, for POST request with 301/302 response, or any request with 303 response, use GET when following redirect\n\n\n        if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n          request.method = 'GET';\n          request.body = null;\n          request.headers.delete('content-length');\n        }\n\n        request.counter++;\n        resolve(fetch(resolvedUrl, request));\n        return;\n      } // normalize location header for manual redirect mode\n\n\n      const headers = new Headers();\n\n      for (const name of Object.keys(res.headers)) {\n        if (Array.isArray(res.headers[name])) {\n          for (const val of res.headers[name]) {\n            headers.append(name, val);\n          }\n        } else {\n          headers.append(name, res.headers[name]);\n        }\n      }\n\n      if (request.redirect === 'manual' && headers.has('location')) {\n        headers.set('location', url.resolve(request.url, headers.get('location')));\n      } // prepare response\n\n\n      let body = res.pipe(new PassThrough());\n      const responseOptions = {\n        url: request.url,\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: headers,\n        size: request.size,\n        timeout: request.timeout\n      }; // HTTP-network fetch step 16.1.2\n\n      const codings = headers.get('Content-Encoding'); // HTTP-network fetch step 16.1.3: handle content codings\n      // in following scenarios we ignore compression support\n      // 1. compression support is disabled\n      // 2. HEAD request\n      // 3. no Content-Encoding header\n      // 4. no content response (204)\n      // 5. content not modified response (304)\n\n      if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n        resolve(new Response(body, responseOptions));\n        return;\n      } // Be less strict when decoding compressed responses, since sometimes\n      // servers send slightly invalid responses that are still accepted\n      // by common browsers.\n      // Always using Z_SYNC_FLUSH is what cURL does.\n\n\n      const zlibOptions = {\n        flush: zlib.Z_SYNC_FLUSH,\n        finishFlush: zlib.Z_SYNC_FLUSH\n      }; // for gzip\n\n      if (codings === 'gzip' || codings === 'x-gzip') {\n        body = body.pipe(zlib.createGunzip(zlibOptions));\n        resolve(new Response(body, responseOptions));\n        return;\n      } // for deflate\n\n\n      if (codings === 'deflate' || codings === 'x-deflate') {\n        // handle the infamous raw deflate response from old servers\n        // a hack for old IIS and Apache servers\n        const raw = res.pipe(new PassThrough());\n        raw.once('data', chunk => {\n          // see http://stackoverflow.com/questions/37519828\n          if ((chunk[0] & 0x0F) === 0x08) {\n            body = body.pipe(zlib.createInflate(zlibOptions));\n          } else {\n            body = body.pipe(zlib.createInflateRaw(zlibOptions));\n          }\n\n          resolve(new Response(body, responseOptions));\n        });\n        return;\n      } // otherwise, use response as-is\n\n\n      resolve(new Response(body, responseOptions));\n    });\n    writeToStream(req, request);\n  });\n}\n\n;\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */\n\nfetch.isRedirect = code => code === 301 || code === 302 || code === 303 || code === 307 || code === 308; // expose Promise\n\n\nfetch.Promise = global.Promise;\nexports.Headers = Headers;\nexports.Request = Request;\nexports.Response = Response;\nexports.FetchError = FetchError;","map":null,"metadata":{},"sourceType":"script"}