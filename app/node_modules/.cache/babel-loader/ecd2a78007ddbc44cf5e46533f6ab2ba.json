{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst util_1 = require(\"./util\");\n\nconst constants_1 = require(\"./constants\");\n\nconst stream = require(\"stream\");\n/**\n * Validates the provided SocksClientOptions\n * @param options { SocksClientOptions }\n * @param acceptedCommands { string[] } A list of accepted SocksProxy commands.\n */\n\n\nfunction validateSocksClientOptions(options, acceptedCommands = ['connect', 'bind', 'associate']) {\n  // Check SOCKs command option.\n  if (!constants_1.SocksCommand[options.command]) {\n    throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommand, options);\n  } // Check SocksCommand for acceptable command.\n\n\n  if (acceptedCommands.indexOf(options.command) === -1) {\n    throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandForOperation, options);\n  } // Check destination\n\n\n  if (!isValidSocksRemoteHost(options.destination)) {\n    throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);\n  } // Check SOCKS proxy to use\n\n\n  if (!isValidSocksProxy(options.proxy)) {\n    throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);\n  } // Check timeout\n\n\n  if (options.timeout && !isValidTimeoutValue(options.timeout)) {\n    throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);\n  } // Check existing_socket (if provided)\n\n\n  if (options.existing_socket && !(options.existing_socket instanceof stream.Duplex)) {\n    throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsExistingSocket, options);\n  }\n}\n\nexports.validateSocksClientOptions = validateSocksClientOptions;\n/**\n * Validates the SocksClientChainOptions\n * @param options { SocksClientChainOptions }\n */\n\nfunction validateSocksClientChainOptions(options) {\n  // Only connect is supported when chaining.\n  if (options.command !== 'connect') {\n    throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandChain, options);\n  } // Check destination\n\n\n  if (!isValidSocksRemoteHost(options.destination)) {\n    throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);\n  } // Validate proxies (length)\n\n\n  if (!(options.proxies && Array.isArray(options.proxies) && options.proxies.length >= 2)) {\n    throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxiesLength, options);\n  } // Validate proxies\n\n\n  options.proxies.forEach(proxy => {\n    if (!isValidSocksProxy(proxy)) {\n      throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);\n    }\n  }); // Check timeout\n\n  if (options.timeout && !isValidTimeoutValue(options.timeout)) {\n    throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);\n  }\n}\n\nexports.validateSocksClientChainOptions = validateSocksClientChainOptions;\n/**\n * Validates a SocksRemoteHost\n * @param remoteHost { SocksRemoteHost }\n */\n\nfunction isValidSocksRemoteHost(remoteHost) {\n  return remoteHost && typeof remoteHost.host === 'string' && typeof remoteHost.port === 'number' && remoteHost.port >= 0 && remoteHost.port <= 65535;\n}\n/**\n * Validates a SocksProxy\n * @param proxy { SocksProxy }\n */\n\n\nfunction isValidSocksProxy(proxy) {\n  return proxy && (typeof proxy.host === 'string' || typeof proxy.ipaddress === 'string') && typeof proxy.port === 'number' && proxy.port >= 0 && proxy.port <= 65535 && (proxy.type === 4 || proxy.type === 5);\n}\n/**\n * Validates a timeout value.\n * @param value { Number }\n */\n\n\nfunction isValidTimeoutValue(value) {\n  return typeof value === 'number' && value > 0;\n}","map":null,"metadata":{},"sourceType":"script"}