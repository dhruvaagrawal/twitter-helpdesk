{"ast":null,"code":"'use strict';\n\nconst Buffer = require('safe-buffer').Buffer;\n\nconst checkResponse = require('./check-response.js');\n\nconst config = require('./config.js');\n\nconst getAuth = require('./auth.js');\n\nconst fetch = require('make-fetch-happen');\n\nconst JSONStream = require('JSONStream');\n\nconst npa = require('npm-package-arg');\n\nconst {\n  PassThrough\n} = require('stream');\n\nconst qs = require('querystring');\n\nconst url = require('url');\n\nconst zlib = require('zlib');\n\nmodule.exports = regFetch;\n\nfunction regFetch(uri, opts) {\n  opts = config(opts);\n  const registry = opts.spec && pickRegistry(opts.spec, opts) || opts.registry || 'https://registry.npmjs.org/';\n  uri = url.parse(uri).protocol ? uri : `${registry.trim().replace(/\\/?$/g, '')}/${uri.trim().replace(/^\\//, '')}`; // through that takes into account the scope, the prefix of `uri`, etc\n\n  const startTime = Date.now();\n  const headers = getHeaders(registry, uri, opts);\n  let body = opts.body;\n  const bodyIsStream = body && typeof body === 'object' && typeof body.pipe === 'function';\n\n  if (body && !bodyIsStream && typeof body !== 'string' && !Buffer.isBuffer(body)) {\n    headers['content-type'] = headers['content-type'] || 'application/json';\n    body = JSON.stringify(body);\n  } else if (body && !headers['content-type']) {\n    headers['content-type'] = 'application/octet-stream';\n  }\n\n  if (opts.gzip) {\n    headers['content-encoding'] = 'gzip';\n\n    if (bodyIsStream) {\n      const gz = zlib.createGzip();\n      body.on('error', err => gz.emit('error', err));\n      body = body.pipe(gz);\n    } else {\n      body = new opts.Promise((resolve, reject) => {\n        zlib.gzip(body, (err, gz) => err ? reject(err) : resolve(gz));\n      });\n    }\n  }\n\n  let q = opts.query;\n\n  if (q) {\n    if (typeof q === 'string') {\n      q = qs.parse(q);\n    } else if (typeof q !== 'object') {\n      throw new TypeError('invalid query option, must be string or object');\n    }\n\n    Object.keys(q).forEach(key => {\n      if (q[key] === undefined) {\n        delete q[key];\n      }\n    });\n  }\n\n  const parsed = url.parse(uri);\n  const query = parsed.query ? Object.assign(qs.parse(parsed.query), q || {}) : Object.keys(q || {}).length ? q : null;\n\n  if (query) {\n    if (String(query.write) === 'true' && opts.method === 'GET') {\n      opts = opts.concat({\n        offline: false,\n        'prefer-offline': false,\n        'prefer-online': true\n      });\n    }\n\n    parsed.search = '?' + qs.stringify(query);\n    uri = url.format(parsed);\n  }\n\n  return opts.Promise.resolve(body).then(body => fetch(uri, {\n    agent: opts.agent,\n    algorithms: opts.algorithms,\n    body,\n    cache: getCacheMode(opts),\n    cacheManager: opts.cache,\n    ca: opts.ca,\n    cert: opts.cert,\n    headers,\n    integrity: opts.integrity,\n    key: opts.key,\n    localAddress: opts['local-address'],\n    maxSockets: opts.maxsockets,\n    memoize: opts.memoize,\n    method: opts.method || 'GET',\n    noProxy: opts['no-proxy'] || opts.noproxy,\n    Promise: opts.Promise,\n    proxy: opts['https-proxy'] || opts.proxy,\n    referer: opts.refer,\n    retry: opts.retry != null ? opts.retry : {\n      retries: opts['fetch-retries'],\n      factor: opts['fetch-retry-factor'],\n      minTimeout: opts['fetch-retry-mintimeout'],\n      maxTimeout: opts['fetch-retry-maxtimeout']\n    },\n    strictSSL: !!opts['strict-ssl'],\n    timeout: opts.timeout\n  }).then(res => checkResponse(opts.method || 'GET', res, registry, startTime, opts)));\n}\n\nmodule.exports.json = fetchJSON;\n\nfunction fetchJSON(uri, opts) {\n  return regFetch(uri, opts).then(res => res.json());\n}\n\nmodule.exports.json.stream = fetchJSONStream;\n\nfunction fetchJSONStream(uri, jsonPath, opts) {\n  opts = config(opts);\n  const parser = JSONStream.parse(jsonPath, opts.mapJson);\n  const pt = parser.pipe(new PassThrough({\n    objectMode: true\n  }));\n  parser.on('error', err => pt.emit('error', err));\n  regFetch(uri, opts).then(res => {\n    res.body.on('error', err => parser.emit('error', err));\n    res.body.pipe(parser);\n  }, err => pt.emit('error', err));\n  return pt;\n}\n\nmodule.exports.pickRegistry = pickRegistry;\n\nfunction pickRegistry(spec, opts) {\n  spec = npa(spec);\n  opts = config(opts);\n  let registry = spec.scope && opts[spec.scope.replace(/^@?/, '@') + ':registry'];\n\n  if (!registry && opts.scope) {\n    registry = opts[opts.scope.replace(/^@?/, '@') + ':registry'];\n  }\n\n  if (!registry) {\n    registry = opts.registry || 'https://registry.npmjs.org/';\n  }\n\n  return registry;\n}\n\nfunction getCacheMode(opts) {\n  return opts.offline ? 'only-if-cached' : opts['prefer-offline'] ? 'force-cache' : opts['prefer-online'] ? 'no-cache' : 'default';\n}\n\nfunction getHeaders(registry, uri, opts) {\n  const headers = Object.assign({\n    'npm-in-ci': !!(opts['is-from-ci'] || process.env['CI'] === 'true' || process.env['TDDIUM'] || process.env['JENKINS_URL'] || process.env['bamboo.buildKey'] || process.env['GO_PIPELINE_NAME']),\n    'npm-scope': opts['project-scope'],\n    'npm-session': opts['npm-session'],\n    'user-agent': opts['user-agent'],\n    'referer': opts.refer\n  }, opts.headers);\n  const auth = getAuth(registry, opts); // If a tarball is hosted on a different place than the manifest, only send\n  // credentials on `alwaysAuth`\n\n  const shouldAuth = auth.alwaysAuth || url.parse(uri).host === url.parse(registry).host;\n\n  if (shouldAuth && auth.token) {\n    headers.authorization = `Bearer ${auth.token}`;\n  } else if (shouldAuth && auth.username && auth.password) {\n    const encoded = Buffer.from(`${auth.username}:${auth.password}`, 'utf8').toString('base64');\n    headers.authorization = `Basic ${encoded}`;\n  } else if (shouldAuth && auth._auth) {\n    headers.authorization = `Basic ${auth._auth}`;\n  }\n\n  if (shouldAuth && auth.otp) {\n    headers['npm-otp'] = auth.otp;\n  }\n\n  return headers;\n}","map":null,"metadata":{},"sourceType":"script"}