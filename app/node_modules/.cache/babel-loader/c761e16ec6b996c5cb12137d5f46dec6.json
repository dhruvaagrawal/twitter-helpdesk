{"ast":null,"code":"var CC = require('config-chain').ConfigChain;\n\nvar inherits = require('inherits');\n\nvar configDefs = require('./defaults.js');\n\nvar types = configDefs.types;\n\nvar once = require('once');\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar nopt = require('nopt');\n\nvar ini = require('ini');\n\nvar Umask = configDefs.Umask;\n\nvar mkdirp = require('gentle-fs').mkdir;\n\nvar umask = require('../utils/umask');\n\nvar isWindows = require('../utils/is-windows.js');\n\nexports.load = load;\nexports.Conf = Conf;\nexports.loaded = false;\nexports.rootConf = null;\nexports.usingBuiltin = false;\nexports.defs = configDefs;\nObject.defineProperty(exports, 'defaults', {\n  get: function () {\n    return configDefs.defaults;\n  },\n  enumerable: true\n});\nObject.defineProperty(exports, 'types', {\n  get: function () {\n    return configDefs.types;\n  },\n  enumerable: true\n});\nexports.validate = validate;\nvar myUid = process.getuid && process.getuid();\nvar myGid = process.getgid && process.getgid();\nvar loading = false;\nvar loadCbs = [];\n\nfunction load() {\n  var cli, builtin, cb;\n\n  for (var i = 0; i < arguments.length; i++) {\n    switch (typeof arguments[i]) {\n      case 'string':\n        builtin = arguments[i];\n        break;\n\n      case 'object':\n        cli = arguments[i];\n        break;\n\n      case 'function':\n        cb = arguments[i];\n        break;\n    }\n  }\n\n  if (!cb) cb = function () {};\n\n  if (exports.loaded) {\n    var ret = exports.loaded;\n\n    if (cli) {\n      ret = new Conf(ret);\n      ret.unshift(cli);\n    }\n\n    return process.nextTick(cb.bind(null, null, ret));\n  } // either a fresh object, or a clone of the passed in obj\n\n\n  if (!cli) {\n    cli = {};\n  } else {\n    cli = Object.keys(cli).reduce(function (c, k) {\n      c[k] = cli[k];\n      return c;\n    }, {});\n  }\n\n  loadCbs.push(cb);\n  if (loading) return;\n  loading = true;\n  cb = once(function (er, conf) {\n    if (!er) {\n      exports.loaded = conf;\n      loading = false;\n    }\n\n    loadCbs.forEach(function (fn) {\n      fn(er, conf);\n    });\n    loadCbs.length = 0;\n  }); // check for a builtin if provided.\n\n  exports.usingBuiltin = !!builtin;\n  var rc = exports.rootConf = new Conf();\n\n  if (builtin) {\n    rc.addFile(builtin, 'builtin');\n  } else {\n    rc.add({}, 'builtin');\n  }\n\n  rc.on('load', function () {\n    load_(builtin, rc, cli, cb);\n  });\n  rc.on('error', cb);\n}\n\nfunction load_(builtin, rc, cli, cb) {\n  var defaults = configDefs.defaults;\n  var conf = new Conf(rc);\n  conf.usingBuiltin = !!builtin;\n  conf.add(cli, 'cli');\n  conf.addEnv();\n  conf.loadPrefix(function (er) {\n    if (er) return cb(er); // If you're doing `npm --userconfig=~/foo.npmrc` then you'd expect\n    // that ~/.npmrc won't override the stuff in ~/foo.npmrc (or, indeed\n    // be used at all).\n    //\n    // However, if the cwd is ~, then ~/.npmrc is the home for the project\n    // config, and will override the userconfig.\n    //\n    // If you're not setting the userconfig explicitly, then it will be loaded\n    // twice, which is harmless but excessive.  If you *are* setting the\n    // userconfig explicitly then it will override your explicit intent, and\n    // that IS harmful and unexpected.\n    //\n    // Solution: Do not load project config file that is the same as either\n    // the default or resolved userconfig value.  npm will log a \"verbose\"\n    // message about this when it happens, but it is a rare enough edge case\n    // that we don't have to be super concerned about it.\n\n    var projectConf = path.resolve(conf.localPrefix, '.npmrc');\n    var defaultUserConfig = rc.get('userconfig');\n    var resolvedUserConfig = conf.get('userconfig');\n\n    if (!conf.get('global') && projectConf !== defaultUserConfig && projectConf !== resolvedUserConfig) {\n      conf.addFile(projectConf, 'project');\n      conf.once('load', afterPrefix);\n    } else {\n      conf.add({}, 'project');\n      afterPrefix();\n    }\n  });\n\n  function afterPrefix() {\n    conf.addFile(conf.get('userconfig'), 'user');\n    conf.once('error', cb);\n    conf.once('load', afterUser);\n  }\n\n  function afterUser() {\n    // globalconfig and globalignorefile defaults\n    // need to respond to the 'prefix' setting up to this point.\n    // Eg, `npm config get globalconfig --prefix ~/local` should\n    // return `~/local/etc/npmrc`\n    // annoying humans and their expectations!\n    if (conf.get('prefix')) {\n      var etc = path.resolve(conf.get('prefix'), 'etc');\n      defaults.globalconfig = path.resolve(etc, 'npmrc');\n      defaults.globalignorefile = path.resolve(etc, 'npmignore');\n    }\n\n    conf.addFile(conf.get('globalconfig'), 'global'); // move the builtin into the conf stack now.\n\n    conf.root = defaults;\n    conf.add(rc.shift(), 'builtin');\n    conf.once('load', function () {\n      conf.loadExtras(afterExtras);\n    });\n  }\n\n  function afterExtras(er) {\n    if (er) return cb(er); // warn about invalid bits.\n\n    validate(conf);\n    var cafile = conf.get('cafile');\n\n    if (cafile) {\n      return conf.loadCAFile(cafile, finalize);\n    }\n\n    finalize();\n  }\n\n  function finalize(er) {\n    if (er) {\n      return cb(er);\n    }\n\n    exports.loaded = conf;\n    cb(er, conf);\n  }\n} // Basically the same as CC, but:\n// 1. Always ini\n// 2. Parses environment variable names in field values\n// 3. Field values that start with ~/ are replaced with process.env.HOME\n// 4. Can inherit from another Conf object, using it as the base.\n\n\ninherits(Conf, CC);\n\nfunction Conf(base) {\n  if (!(this instanceof Conf)) return new Conf(base);\n  CC.call(this);\n\n  if (base) {\n    if (base instanceof Conf) {\n      this.root = base.list[0] || base.root;\n    } else {\n      this.root = base;\n    }\n  } else {\n    this.root = configDefs.defaults;\n  }\n}\n\nConf.prototype.loadPrefix = require('./load-prefix.js');\nConf.prototype.loadCAFile = require('./load-cafile.js');\nConf.prototype.setUser = require('./set-user.js');\nConf.prototype.getCredentialsByURI = require('./get-credentials-by-uri.js');\nConf.prototype.setCredentialsByURI = require('./set-credentials-by-uri.js');\nConf.prototype.clearCredentialsByURI = require('./clear-credentials-by-uri.js');\n\nConf.prototype.loadExtras = function (cb) {\n  this.setUser(function (er) {\n    if (er) return cb(er); // Without prefix, nothing will ever work\n\n    mkdirp(this.prefix, cb);\n  }.bind(this));\n};\n\nConf.prototype.save = function (where, cb) {\n  var target = this.sources[where];\n\n  if (!target || !(target.path || target.source) || !target.data) {\n    var er;\n    if (where !== 'builtin') er = new Error('bad save target: ' + where);\n\n    if (cb) {\n      process.nextTick(cb.bind(null, er));\n      return this;\n    }\n\n    return this.emit('error', er);\n  }\n\n  if (target.source) {\n    var pref = target.prefix || '';\n    Object.keys(target.data).forEach(function (k) {\n      target.source[pref + k] = target.data[k];\n    });\n    if (cb) process.nextTick(cb);\n    return this;\n  }\n\n  var data = ini.stringify(target.data);\n\n  var then = function then(er) {\n    if (er) return done(er);\n    fs.chmod(target.path, mode, done);\n  };\n\n  var done = function done(er) {\n    if (er) {\n      if (cb) return cb(er);else return this.emit('error', er);\n    }\n\n    this._saving--;\n\n    if (this._saving === 0) {\n      if (cb) cb();\n      this.emit('save');\n    }\n  };\n\n  then = then.bind(this);\n  done = done.bind(this);\n  this._saving++;\n  var mode = where === 'user' ? '0600' : '0666';\n\n  if (!data.trim()) {\n    fs.unlink(target.path, function () {\n      // ignore the possible error (e.g. the file doesn't exist)\n      done(null);\n    });\n  } else {\n    // we don't have to use inferOwner here, because gentle-fs will\n    // mkdir with the correctly inferred ownership.  Just preserve it.\n    const dir = path.dirname(target.path);\n    mkdirp(dir, function (er) {\n      if (er) return then(er);\n      fs.stat(dir, (er, st) => {\n        if (er) return then(er);\n        fs.writeFile(target.path, data, 'utf8', function (er) {\n          if (er) return then(er);\n\n          if (myUid === 0 && (myUid !== st.uid || myGid !== st.gid)) {\n            fs.chown(target.path, st.uid, st.gid, then);\n          } else {\n            then();\n          }\n        });\n      });\n    });\n  }\n\n  return this;\n};\n\nConf.prototype.addFile = function (file, name) {\n  name = name || file;\n  var marker = {\n    __source__: name\n  };\n  this.sources[name] = {\n    path: file,\n    type: 'ini'\n  };\n  this.push(marker);\n\n  this._await();\n\n  fs.readFile(file, 'utf8', function (er, data) {\n    // just ignore missing files.\n    if (er) return this.add({}, marker);\n    this.addString(data, file, 'ini', marker);\n  }.bind(this));\n  return this;\n}; // always ini files.\n\n\nConf.prototype.parse = function (content, file) {\n  return CC.prototype.parse.call(this, content, file, 'ini');\n};\n\nConf.prototype.add = function (data, marker) {\n  try {\n    Object.keys(data).forEach(function (k) {\n      const newKey = envReplace(k);\n      const newField = parseField(data[k], newKey);\n      delete data[k];\n      data[newKey] = newField;\n    });\n  } catch (e) {\n    this.emit('error', e);\n    return this;\n  }\n\n  return CC.prototype.add.call(this, data, marker);\n};\n\nConf.prototype.addEnv = function (env) {\n  env = env || process.env;\n  var conf = {};\n  Object.keys(env).filter(function (k) {\n    return k.match(/^npm_config_/i);\n  }).forEach(function (k) {\n    if (!env[k]) return; // leave first char untouched, even if\n    // it is a '_' - convert all other to '-'\n\n    var p = k.toLowerCase().replace(/^npm_config_/, '').replace(/(?!^)_/g, '-');\n    conf[p] = env[k];\n  });\n  return CC.prototype.addEnv.call(this, '', conf, 'env');\n};\n\nfunction parseField(f, k) {\n  if (typeof f !== 'string' && !(f instanceof String)) return f; // type can be an array or single thing.\n\n  var typeList = [].concat(types[k]);\n  var isPath = typeList.indexOf(path) !== -1;\n  var isBool = typeList.indexOf(Boolean) !== -1;\n  var isString = typeList.indexOf(String) !== -1;\n  var isUmask = typeList.indexOf(Umask) !== -1;\n  var isNumber = typeList.indexOf(Number) !== -1;\n  f = ('' + f).trim();\n\n  if (f.match(/^\".*\"$/)) {\n    try {\n      f = JSON.parse(f);\n    } catch (e) {\n      throw new Error('Failed parsing JSON config key ' + k + ': ' + f);\n    }\n  }\n\n  if (isBool && !isString && f === '') return true;\n\n  switch (f) {\n    case 'true':\n      return true;\n\n    case 'false':\n      return false;\n\n    case 'null':\n      return null;\n\n    case 'undefined':\n      return undefined;\n  }\n\n  f = envReplace(f);\n\n  if (isPath) {\n    var homePattern = isWindows ? /^~(\\/|\\\\)/ : /^~\\//;\n\n    if (f.match(homePattern) && process.env.HOME) {\n      f = path.resolve(process.env.HOME, f.substr(2));\n    }\n\n    f = path.resolve(f);\n  }\n\n  if (isUmask) f = umask.fromString(f);\n  if (isNumber && !isNaN(f)) f = +f;\n  return f;\n}\n\nfunction envReplace(f) {\n  if (typeof f !== 'string' || !f) return f; // replace any ${ENV} values with the appropriate environ.\n\n  var envExpr = /(\\\\*)\\$\\{([^}]+)\\}/g;\n  return f.replace(envExpr, function (orig, esc, name) {\n    esc = esc.length && esc.length % 2;\n    if (esc) return orig;\n\n    if (undefined === process.env[name]) {\n      throw new Error('Failed to replace env in config: ' + orig);\n    }\n\n    return process.env[name];\n  });\n}\n\nfunction validate(cl) {\n  // warn about invalid configs at every level.\n  cl.list.forEach(function (conf) {\n    nopt.clean(conf, configDefs.types);\n  });\n  nopt.clean(cl.root, configDefs.types);\n}","map":null,"metadata":{},"sourceType":"script"}