{"ast":null,"code":"'use strict';\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */\n\nconst common = require('./common.js');\n\nconst checkInvalidHeaderChar = common.checkInvalidHeaderChar;\nconst checkIsHttpToken = common.checkIsHttpToken;\n\nfunction sanitizeName(name) {\n  name += '';\n\n  if (!checkIsHttpToken(name)) {\n    throw new TypeError(`${name} is not a legal HTTP header name`);\n  }\n\n  return name.toLowerCase();\n}\n\nfunction sanitizeValue(value) {\n  value += '';\n\n  if (checkInvalidHeaderChar(value)) {\n    throw new TypeError(`${value} is not a legal HTTP header value`);\n  }\n\n  return value;\n}\n\nconst MAP = Symbol('map');\n\nclass Headers {\n  /**\n   * Headers class\n   *\n   * @param   Object  headers  Response headers\n   * @return  Void\n   */\n  constructor(init) {\n    this[MAP] = Object.create(null);\n\n    if (init instanceof Headers) {\n      const rawHeaders = init.raw();\n      const headerNames = Object.keys(rawHeaders);\n\n      for (const headerName of headerNames) {\n        for (const value of rawHeaders[headerName]) {\n          this.append(headerName, value);\n        }\n      }\n\n      return;\n    } // We don't worry about converting prop to ByteString here as append()\n    // will handle it.\n\n\n    if (init == null) {// no op\n    } else if (typeof init === 'object') {\n      const method = init[Symbol.iterator];\n\n      if (method != null) {\n        if (typeof method !== 'function') {\n          throw new TypeError('Header pairs must be iterable');\n        } // sequence<sequence<ByteString>>\n        // Note: per spec we have to first exhaust the lists then process them\n\n\n        const pairs = [];\n\n        for (const pair of init) {\n          if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n            throw new TypeError('Each header pair must be iterable');\n          }\n\n          pairs.push(Array.from(pair));\n        }\n\n        for (const pair of pairs) {\n          if (pair.length !== 2) {\n            throw new TypeError('Each header pair must be a name/value tuple');\n          }\n\n          this.append(pair[0], pair[1]);\n        }\n      } else {\n        // record<ByteString, ByteString>\n        for (const key of Object.keys(init)) {\n          const value = init[key];\n          this.append(key, value);\n        }\n      }\n    } else {\n      throw new TypeError('Provided initializer must be an object');\n    }\n\n    Object.defineProperty(this, Symbol.toStringTag, {\n      value: 'Headers',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n  }\n  /**\n   * Return first header value given name\n   *\n   * @param   String  name  Header name\n   * @return  Mixed\n   */\n\n\n  get(name) {\n    const list = this[MAP][sanitizeName(name)];\n\n    if (!list) {\n      return null;\n    }\n\n    return list.join(', ');\n  }\n  /**\n   * Iterate over all headers\n   *\n   * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n   * @param   Boolean   thisArg   `this` context for callback function\n   * @return  Void\n   */\n\n\n  forEach(callback, thisArg) {\n    let pairs = getHeaderPairs(this);\n    let i = 0;\n\n    while (i < pairs.length) {\n      const name = pairs[i][0];\n      const value = pairs[i][1];\n      callback.call(thisArg, value, name, this);\n      pairs = getHeaderPairs(this);\n      i++;\n    }\n  }\n  /**\n   * Overwrite header values given name\n   *\n   * @param   String  name   Header name\n   * @param   String  value  Header value\n   * @return  Void\n   */\n\n\n  set(name, value) {\n    this[MAP][sanitizeName(name)] = [sanitizeValue(value)];\n  }\n  /**\n   * Append a value onto existing header\n   *\n   * @param   String  name   Header name\n   * @param   String  value  Header value\n   * @return  Void\n   */\n\n\n  append(name, value) {\n    if (!this.has(name)) {\n      this.set(name, value);\n      return;\n    }\n\n    this[MAP][sanitizeName(name)].push(sanitizeValue(value));\n  }\n  /**\n   * Check for header name existence\n   *\n   * @param   String   name  Header name\n   * @return  Boolean\n   */\n\n\n  has(name) {\n    return !!this[MAP][sanitizeName(name)];\n  }\n  /**\n   * Delete all header values given name\n   *\n   * @param   String  name  Header name\n   * @return  Void\n   */\n\n\n  delete(name) {\n    delete this[MAP][sanitizeName(name)];\n  }\n\n  /**\n   * Return raw headers (non-spec api)\n   *\n   * @return  Object\n   */\n  raw() {\n    return this[MAP];\n  }\n  /**\n   * Get an iterator on keys.\n   *\n   * @return  Iterator\n   */\n\n\n  keys() {\n    return createHeadersIterator(this, 'key');\n  }\n  /**\n   * Get an iterator on values.\n   *\n   * @return  Iterator\n   */\n\n\n  values() {\n    return createHeadersIterator(this, 'value');\n  }\n  /**\n   * Get an iterator on entries.\n   *\n   * This is the default iterator of the Headers object.\n   *\n   * @return  Iterator\n   */\n\n\n  [Symbol.iterator]() {\n    return createHeadersIterator(this, 'key+value');\n  }\n\n}\n\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n  value: 'HeadersPrototype',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\n\nfunction getHeaderPairs(headers, kind) {\n  const keys = Object.keys(headers[MAP]).sort();\n  return keys.map(kind === 'key' ? k => [k] : k => [k, headers.get(k)]);\n}\n\nconst INTERNAL = Symbol('internal');\n\nfunction createHeadersIterator(target, kind) {\n  const iterator = Object.create(HeadersIteratorPrototype);\n  iterator[INTERNAL] = {\n    target,\n    kind,\n    index: 0\n  };\n  return iterator;\n}\n\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n  next() {\n    // istanbul ignore if\n    if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n      throw new TypeError('Value of `this` is not a HeadersIterator');\n    }\n\n    const target = this[INTERNAL].target;\n    const kind = this[INTERNAL].kind;\n    const index = this[INTERNAL].index;\n    const values = getHeaderPairs(target, kind);\n    const len = values.length;\n\n    if (index >= len) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const pair = values[index];\n    this[INTERNAL].index = index + 1;\n    let result;\n\n    if (kind === 'key') {\n      result = pair[0];\n    } else if (kind === 'value') {\n      result = pair[1];\n    } else {\n      result = pair;\n    }\n\n    return {\n      value: result,\n      done: false\n    };\n  }\n\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n  value: 'HeadersIterator',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\nmodule.exports = Headers;","map":null,"metadata":{},"sourceType":"script"}