{"ast":null,"code":"'use strict';\n\nclass FiggyPudding {\n  constructor(specs, opts, providers) {\n    this.__specs = specs || {};\n    Object.keys(this.__specs).forEach(alias => {\n      if (typeof this.__specs[alias] === 'string') {\n        const key = this.__specs[alias];\n        const realSpec = this.__specs[key];\n\n        if (realSpec) {\n          const aliasArr = realSpec.aliases || [];\n          aliasArr.push(alias, key);\n          realSpec.aliases = [...new Set(aliasArr)];\n          this.__specs[alias] = realSpec;\n        } else {\n          throw new Error(`Alias refers to invalid key: ${key} -> ${alias}`);\n        }\n      }\n    });\n    this.__opts = opts || {};\n    this.__providers = reverse(providers.filter(x => x != null && typeof x === 'object'));\n    this.__isFiggyPudding = true;\n  }\n\n  get(key) {\n    return pudGet(this, key, true);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'FiggyPudding';\n  }\n\n  forEach(fn, thisArg = this) {\n    for (let [key, value] of this.entries()) {\n      fn.call(thisArg, value, key, this);\n    }\n  }\n\n  toJSON() {\n    const obj = {};\n    this.forEach((val, key) => {\n      obj[key] = val;\n    });\n    return obj;\n  }\n\n  *entries(_matcher) {\n    for (let key of Object.keys(this.__specs)) {\n      yield [key, this.get(key)];\n    }\n\n    const matcher = _matcher || this.__opts.other;\n\n    if (matcher) {\n      const seen = new Set();\n\n      for (let p of this.__providers) {\n        const iter = p.entries ? p.entries(matcher) : entries(p);\n\n        for (let [key, val] of iter) {\n          if (matcher(key) && !seen.has(key)) {\n            seen.add(key);\n            yield [key, val];\n          }\n        }\n      }\n    }\n  }\n\n  *[Symbol.iterator]() {\n    for (let [key, value] of this.entries()) {\n      yield [key, value];\n    }\n  }\n\n  *keys() {\n    for (let [key] of this.entries()) {\n      yield key;\n    }\n  }\n\n  *values() {\n    for (let [, value] of this.entries()) {\n      yield value;\n    }\n  }\n\n  concat(...moreConfig) {\n    return new Proxy(new FiggyPudding(this.__specs, this.__opts, reverse(this.__providers).concat(moreConfig)), proxyHandler);\n  }\n\n}\n\ntry {\n  const util = require('util');\n\n  FiggyPudding.prototype[util.inspect.custom] = function (depth, opts) {\n    return this[Symbol.toStringTag] + ' ' + util.inspect(this.toJSON(), opts);\n  };\n} catch (e) {}\n\nfunction BadKeyError(key) {\n  throw Object.assign(new Error(`invalid config key requested: ${key}`), {\n    code: 'EBADKEY'\n  });\n}\n\nfunction pudGet(pud, key, validate) {\n  let spec = pud.__specs[key];\n\n  if (validate && !spec && (!pud.__opts.other || !pud.__opts.other(key))) {\n    BadKeyError(key);\n  } else {\n    if (!spec) {\n      spec = {};\n    }\n\n    let ret;\n\n    for (let p of pud.__providers) {\n      ret = tryGet(key, p);\n\n      if (ret === undefined && spec.aliases && spec.aliases.length) {\n        for (let alias of spec.aliases) {\n          if (alias === key) {\n            continue;\n          }\n\n          ret = tryGet(alias, p);\n\n          if (ret !== undefined) {\n            break;\n          }\n        }\n      }\n\n      if (ret !== undefined) {\n        break;\n      }\n    }\n\n    if (ret === undefined && spec.default !== undefined) {\n      if (typeof spec.default === 'function') {\n        return spec.default(pud);\n      } else {\n        return spec.default;\n      }\n    } else {\n      return ret;\n    }\n  }\n}\n\nfunction tryGet(key, p) {\n  let ret;\n\n  if (p.__isFiggyPudding) {\n    ret = pudGet(p, key, false);\n  } else if (typeof p.get === 'function') {\n    ret = p.get(key);\n  } else {\n    ret = p[key];\n  }\n\n  return ret;\n}\n\nconst proxyHandler = {\n  has(obj, prop) {\n    return prop in obj.__specs && pudGet(obj, prop, false) !== undefined;\n  },\n\n  ownKeys(obj) {\n    return Object.keys(obj.__specs);\n  },\n\n  get(obj, prop) {\n    if (typeof prop === 'symbol' || prop.slice(0, 2) === '__' || prop in FiggyPudding.prototype) {\n      return obj[prop];\n    }\n\n    return obj.get(prop);\n  },\n\n  set(obj, prop, value) {\n    if (typeof prop === 'symbol' || prop.slice(0, 2) === '__') {\n      obj[prop] = value;\n      return true;\n    } else {\n      throw new Error('figgyPudding options cannot be modified. Use .concat() instead.');\n    }\n  },\n\n  deleteProperty() {\n    throw new Error('figgyPudding options cannot be deleted. Use .concat() and shadow them instead.');\n  }\n\n};\nmodule.exports = figgyPudding;\n\nfunction figgyPudding(specs, opts) {\n  function factory(...providers) {\n    return new Proxy(new FiggyPudding(specs, opts, providers), proxyHandler);\n  }\n\n  return factory;\n}\n\nfunction reverse(arr) {\n  const ret = [];\n  arr.forEach(x => ret.unshift(x));\n  return ret;\n}\n\nfunction entries(obj) {\n  return Object.keys(obj).map(k => [k, obj[k]]);\n}","map":null,"metadata":{},"sourceType":"script"}