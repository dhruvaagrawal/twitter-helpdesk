{"ast":null,"code":"class Utils {\n  /**\r\n   * Get first character from first & last sentences of a username\r\n   * @param {String} name - Username\r\n   * @return {String} 2 characters string\r\n   */\n  static getNameInitial(name) {\n    let initials = name.match(/\\b\\w/g) || [];\n    return ((initials.shift() || '') + (initials.pop() || '')).toUpperCase();\n  }\n  /**\r\n   * Get current path related object from Navigation Tree\r\n   * @param {Array} navTree - Navigation Tree from directory 'configs/NavigationConfig'\r\n   * @param {String} path - Location path you looking for e.g '/app/dashboards/analytic'\r\n   * @return {Object} object that contained the path string\r\n   */\n\n\n  static getRouteInfo(navTree, path) {\n    if (navTree.path === path) {\n      return navTree;\n    }\n\n    let route;\n\n    for (let p in navTree) {\n      if (navTree.hasOwnProperty(p) && typeof navTree[p] === 'object') {\n        route = this.getRouteInfo(navTree[p], path);\n\n        if (route) {\n          return route;\n        }\n      }\n    }\n\n    return route;\n  }\n  /**\r\n   * Get accessible color contrast\r\n   * @param {String} hex - Hex color code e.g '#3e82f7'\r\n   * @return {String} 'dark' or 'light'\r\n   */\n\n\n  static getColorContrast(hex) {\n    const threshold = 130;\n    const hRed = hexToR(hex);\n    const hGreen = hexToG(hex);\n    const hBlue = hexToB(hex);\n\n    function hexToR(h) {\n      return parseInt(cutHex(h).substring(0, 2), 16);\n    }\n\n    function hexToG(h) {\n      return parseInt(cutHex(h).substring(2, 4), 16);\n    }\n\n    function hexToB(h) {\n      return parseInt(cutHex(h).substring(4, 6), 16);\n    }\n\n    function cutHex(h) {\n      return h.charAt(0) === '#' ? h.substring(1, 7) : h;\n    }\n\n    const cBrightness = (hRed * 299 + hGreen * 587 + hBlue * 114) / 1000;\n\n    if (cBrightness > threshold) {\n      return 'dark';\n    } else {\n      return 'light';\n    }\n  }\n  /**\r\n   * Darken or lighten a hex color \r\n   * @param {String} color - Hex color code e.g '#3e82f7'\r\n   * @param {Number} percent - Percentage -100 to 100, positive for lighten, negative for darken\r\n   * @return {String} Darken or lighten color \r\n   */\n\n\n  static shadeColor(color, percent) {\n    let R = parseInt(color.substring(1, 3), 16);\n    let G = parseInt(color.substring(3, 5), 16);\n    let B = parseInt(color.substring(5, 7), 16);\n    R = parseInt(R * (100 + percent) / 100);\n    G = parseInt(G * (100 + percent) / 100);\n    B = parseInt(B * (100 + percent) / 100);\n    R = R < 255 ? R : 255;\n    G = G < 255 ? G : 255;\n    B = B < 255 ? B : 255;\n    const RR = R.toString(16).length === 1 ? `0${R.toString(16)}` : R.toString(16);\n    const GG = G.toString(16).length === 1 ? `0${G.toString(16)}` : G.toString(16);\n    const BB = B.toString(16).length === 1 ? `0${B.toString(16)}` : B.toString(16);\n    return `#${RR}${GG}${BB}`;\n  }\n  /**\r\n   * Returns either a positive or negative \r\n   * @param {Number} number - number value\r\n   * @param {any} positive - value that return when positive\r\n   * @param {any} negative - value that return when negative\r\n   * @return {any} positive or negative value based on param\r\n   */\n\n\n  static getSignNum(number, positive, negative) {\n    if (number > 0) {\n      return positive;\n    }\n\n    if (number < 0) {\n      return negative;\n    }\n\n    return null;\n  }\n  /**\r\n   * Returns either ascending or descending value\r\n   * @param {Object} a - antd Table sorter param a\r\n   * @param {Object} b - antd Table sorter param b\r\n   * @param {String} key - object key for compare\r\n   * @return {any} a value minus b value\r\n   */\n\n\n  static antdTableSorter(a, b, key) {\n    if (typeof a[key] === 'number' && typeof b[key] === 'number') {\n      return a[key] - b[key];\n    }\n\n    if (typeof a[key] === 'string' && typeof b[key] === 'string') {\n      a = a[key].toLowerCase();\n      b = b[key].toLowerCase();\n      return a > b ? -1 : b > a ? 1 : 0;\n    }\n\n    return;\n  }\n  /**\r\n   * Filter array of object \r\n   * @param {Array} list - array of objects that need to filter\r\n   * @param {String} key - object key target\r\n   * @param {any} value  - value that excluded from filter\r\n   * @return {Array} a value minus b value\r\n   */\n\n\n  static filterArray(list, key, value) {\n    let data = list;\n\n    if (list) {\n      data = list.filter(item => item[key] === value);\n    }\n\n    return data;\n  }\n  /**\r\n   * Remove object from array by value\r\n   * @param {Array} list - array of objects\r\n   * @param {String} key - object key target\r\n   * @param {any} value  - target value\r\n   * @return {Array} Array that removed target object\r\n   */\n\n\n  static deleteArrayRow(list, key, value) {\n    let data = list;\n\n    if (list) {\n      data = list.filter(item => item[key] !== value);\n    }\n\n    return data;\n  }\n  /**\r\n   * Wild card search on all property of the object\r\n   * @param {Number | String} input - any value to search\r\n   * @param {Array} list - array for search\r\n   * @return {Array} array of object contained keyword\r\n   */\n\n\n  static wildCardSearch(list, input) {\n    const searchText = item => {\n      for (let key in item) {\n        if (item[key] == null) {\n          continue;\n        }\n\n        if (item[key].toString().toUpperCase().indexOf(input.toString().toUpperCase()) !== -1) {\n          return true;\n        }\n      }\n    };\n\n    list = list.filter(value => searchText(value));\n    return list;\n  }\n  /**\r\n   * Get Breakpoint\r\n   * @param {Object} screens - Grid.useBreakpoint() from antd\r\n   * @return {Array} array of breakpoint size\r\n   */\n\n\n  static getBreakPoint(screens) {\n    let breakpoints = [];\n\n    for (const key in screens) {\n      if (screens.hasOwnProperty(key)) {\n        const element = screens[key];\n\n        if (element) {\n          breakpoints.push(key);\n        }\n      }\n    }\n\n    return breakpoints;\n  }\n\n}\n\nexport default Utils;","map":{"version":3,"sources":["/Users/dhruvaagrawal/Desktop/Work/Spocto/CMS/app/src/utils/index.js"],"names":["Utils","getNameInitial","name","initials","match","shift","pop","toUpperCase","getRouteInfo","navTree","path","route","p","hasOwnProperty","getColorContrast","hex","threshold","hRed","hexToR","hGreen","hexToG","hBlue","hexToB","h","parseInt","cutHex","substring","charAt","cBrightness","shadeColor","color","percent","R","G","B","RR","toString","length","GG","BB","getSignNum","number","positive","negative","antdTableSorter","a","b","key","toLowerCase","filterArray","list","value","data","filter","item","deleteArrayRow","wildCardSearch","input","searchText","indexOf","getBreakPoint","screens","breakpoints","element","push"],"mappings":"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","sourcesContent":["class Utils {\r\n\r\n\t/**\r\n\t * Get first character from first & last sentences of a username\r\n\t * @param {String} name - Username\r\n\t * @return {String} 2 characters string\r\n\t */\r\n\tstatic getNameInitial(name) {\r\n\t\tlet initials = name.match(/\\b\\w/g) || [];\r\n\t\treturn ((initials.shift() || '') + (initials.pop() || '')).toUpperCase();\r\n\t}\r\n\r\n\t/**\r\n\t * Get current path related object from Navigation Tree\r\n\t * @param {Array} navTree - Navigation Tree from directory 'configs/NavigationConfig'\r\n\t * @param {String} path - Location path you looking for e.g '/app/dashboards/analytic'\r\n\t * @return {Object} object that contained the path string\r\n\t */\r\n\tstatic getRouteInfo(navTree, path) {\r\n\t\tif( navTree.path === path ){\r\n\t\t  return navTree;\r\n\t\t}\r\n\t\tlet route; \r\n\t\tfor (let p in navTree) {\r\n\t\t  if( navTree.hasOwnProperty(p) && typeof navTree[p] === 'object' ) {\r\n\t\t\t\troute = this.getRouteInfo(navTree[p], path);\r\n\t\t\t\tif(route){\r\n\t\t\t\t\treturn route;\r\n\t\t\t\t}\r\n\t\t  }\r\n\t\t}\r\n\t\treturn route;\r\n\t}\t\r\n\r\n\t/**\r\n\t * Get accessible color contrast\r\n\t * @param {String} hex - Hex color code e.g '#3e82f7'\r\n\t * @return {String} 'dark' or 'light'\r\n\t */\r\n\tstatic getColorContrast(hex){\r\n\t\tconst threshold = 130;\r\n\t\tconst hRed = hexToR(hex);\r\n\t\tconst hGreen = hexToG(hex);\r\n\t\tconst hBlue = hexToB(hex);\r\n\t\tfunction hexToR(h) {return parseInt((cutHex(h)).substring(0,2),16)}\r\n\t\tfunction hexToG(h) {return parseInt((cutHex(h)).substring(2,4),16)}\r\n\t\tfunction hexToB(h) {return parseInt((cutHex(h)).substring(4,6),16)}\r\n\t\tfunction cutHex(h) {return (h.charAt(0) === '#') ? h.substring(1,7):h}\r\n\t\tconst cBrightness = ((hRed * 299) + (hGreen * 587) + (hBlue * 114)) / 1000;\r\n\t\tif (cBrightness > threshold){\r\n\t\t\treturn 'dark'\r\n\t\t} else { \r\n\t\t\treturn 'light'\r\n\t\t}\t\r\n\t}\r\n\r\n\t/**\r\n\t * Darken or lighten a hex color \r\n\t * @param {String} color - Hex color code e.g '#3e82f7'\r\n\t * @param {Number} percent - Percentage -100 to 100, positive for lighten, negative for darken\r\n\t * @return {String} Darken or lighten color \r\n\t */\r\n\tstatic shadeColor(color, percent) {\r\n\t\tlet R = parseInt(color.substring(1,3),16);\r\n\t\tlet G = parseInt(color.substring(3,5),16);\r\n\t\tlet B = parseInt(color.substring(5,7),16);\r\n\t\tR = parseInt(R * (100 + percent) / 100);\r\n\t\tG = parseInt(G * (100 + percent) / 100);\r\n\t\tB = parseInt(B * (100 + percent) / 100);\r\n\t\tR = (R<255)?R:255;  \r\n\t\tG = (G<255)?G:255;  \r\n\t\tB = (B<255)?B:255;  \r\n\t\tconst RR = ((R.toString(16).length === 1) ? `0${R.toString(16)}` : R.toString(16));\r\n\t\tconst GG = ((G.toString(16).length === 1) ? `0${G.toString(16)}` : G.toString(16));\r\n\t\tconst BB = ((B.toString(16).length === 1) ? `0${B.toString(16)}` : B.toString(16));\r\n\t\treturn `#${RR}${GG}${BB}`; \r\n\t}\r\n\r\n\t/**\r\n\t * Returns either a positive or negative \r\n\t * @param {Number} number - number value\r\n\t * @param {any} positive - value that return when positive\r\n\t * @param {any} negative - value that return when negative\r\n\t * @return {any} positive or negative value based on param\r\n\t */\r\n\tstatic getSignNum(number, positive, negative) {\r\n\t\tif (number > 0) {\r\n\t\t\treturn positive\r\n\t\t}\r\n\t\tif (number < 0) {\r\n\t\t\treturn negative\r\n\t\t}\r\n\t\treturn null\r\n\t}\r\n\r\n\t/**\r\n\t * Returns either ascending or descending value\r\n\t * @param {Object} a - antd Table sorter param a\r\n\t * @param {Object} b - antd Table sorter param b\r\n\t * @param {String} key - object key for compare\r\n\t * @return {any} a value minus b value\r\n\t */\r\n\tstatic antdTableSorter(a, b, key) {\r\n\t\tif(typeof a[key] === 'number' && typeof b[key] === 'number') {\r\n\t\t\treturn a[key] - b[key]\r\n\t\t}\r\n\r\n\t\tif(typeof a[key] === 'string' && typeof b[key] === 'string') {\r\n\t\t\ta = a[key].toLowerCase();\r\n\t\t\tb = b[key].toLowerCase();\r\n\t\t\treturn a > b ? -1 : b > a ? 1 : 0;\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\r\n\t/**\r\n\t * Filter array of object \r\n\t * @param {Array} list - array of objects that need to filter\r\n\t * @param {String} key - object key target\r\n\t * @param {any} value  - value that excluded from filter\r\n\t * @return {Array} a value minus b value\r\n\t */\r\n\tstatic filterArray(list, key, value) {\r\n\t\tlet data = list\r\n\t\tif(list) {\r\n\t\t\tdata = list.filter(item => item[key] === value)\r\n\t\t}\r\n\t\treturn data\r\n\t}\r\n\r\n\t/**\r\n\t * Remove object from array by value\r\n\t * @param {Array} list - array of objects\r\n\t * @param {String} key - object key target\r\n\t * @param {any} value  - target value\r\n\t * @return {Array} Array that removed target object\r\n\t */\r\n\tstatic deleteArrayRow(list, key, value) {\r\n\t\tlet data = list\r\n\t\tif(list) {\r\n\t\t\tdata = list.filter(item => item[key] !== value)\r\n\t\t}\r\n\t\treturn data\r\n\t}\r\n\r\n\t/**\r\n\t * Wild card search on all property of the object\r\n\t * @param {Number | String} input - any value to search\r\n\t * @param {Array} list - array for search\r\n\t * @return {Array} array of object contained keyword\r\n\t */\r\n\tstatic wildCardSearch(list, input) {\r\n\t\tconst searchText = (item) => {\r\n\t\t\tfor (let key in item) {\r\n\t\t\t\tif (item[key] == null) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (item[key].toString().toUpperCase().indexOf(input.toString().toUpperCase()) !== -1) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\tlist = list.filter(value => searchText(value));\r\n\t\treturn list;\r\n\t}\r\n\r\n\t/**\r\n\t * Get Breakpoint\r\n\t * @param {Object} screens - Grid.useBreakpoint() from antd\r\n\t * @return {Array} array of breakpoint size\r\n\t */\r\n\tstatic getBreakPoint(screens) {\r\n\t\tlet breakpoints = []\r\n\t\tfor (const key in screens) {\r\n\t\t\tif (screens.hasOwnProperty(key)) {\r\n\t\t\t\tconst element = screens[key];\r\n\t\t\t\tif (element) {\r\n\t\t\t\t\tbreakpoints.push(key)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn breakpoints\r\n\t}\r\n}\r\n\r\nexport default Utils;"]},"metadata":{},"sourceType":"module"}