{"ast":null,"code":"'use strict';\n/**\n * body.js\n *\n * Body interface provides common methods for Request and Response\n */\n\nconst Buffer = require('safe-buffer').Buffer;\n\nconst Blob = require('./blob.js');\n\nconst BUFFER = Blob.BUFFER;\n\nconst convert = require('encoding').convert;\n\nconst parseJson = require('json-parse-better-errors');\n\nconst FetchError = require('./fetch-error.js');\n\nconst Stream = require('stream');\n\nconst PassThrough = Stream.PassThrough;\nconst DISTURBED = Symbol('disturbed');\n/**\n * Body class\n *\n * Cannot use ES6 class because Body must be called with .call().\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\n\nexports = module.exports = Body;\n\nfunction Body(body, opts) {\n  if (!opts) opts = {};\n  const size = opts.size == null ? 0 : opts.size;\n  const timeout = opts.timeout == null ? 0 : opts.timeout;\n\n  if (body == null) {\n    // body is undefined or null\n    body = null;\n  } else if (typeof body === 'string') {// body is string\n  } else if (body instanceof Blob) {// body is blob\n  } else if (Buffer.isBuffer(body)) {// body is buffer\n  } else if (body instanceof Stream) {// body is stream\n  } else {\n    // none of the above\n    // coerce to string\n    body = String(body);\n  }\n\n  this.body = body;\n  this[DISTURBED] = false;\n  this.size = size;\n  this.timeout = timeout;\n}\n\nBody.prototype = {\n  get bodyUsed() {\n    return this[DISTURBED];\n  },\n\n  /**\n   * Decode response as ArrayBuffer\n   *\n   * @return  Promise\n   */\n  arrayBuffer() {\n    return consumeBody.call(this).then(buf => buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength));\n  },\n\n  /**\n   * Return raw response as Blob\n   *\n   * @return Promise\n   */\n  blob() {\n    let ct = this.headers && this.headers.get('content-type') || '';\n    return consumeBody.call(this).then(buf => Object.assign( // Prevent copying\n    new Blob([], {\n      type: ct.toLowerCase()\n    }), {\n      [BUFFER]: buf\n    }));\n  },\n\n  /**\n   * Decode response as json\n   *\n   * @return  Promise\n   */\n  json() {\n    return consumeBody.call(this).then(buffer => parseJson(buffer.toString()));\n  },\n\n  /**\n   * Decode response as text\n   *\n   * @return  Promise\n   */\n  text() {\n    return consumeBody.call(this).then(buffer => buffer.toString());\n  },\n\n  /**\n   * Decode response as buffer (non-spec api)\n   *\n   * @return  Promise\n   */\n  buffer() {\n    return consumeBody.call(this);\n  },\n\n  /**\n   * Decode response as text, while automatically detecting the encoding and\n   * trying to decode to UTF-8 (non-spec api)\n   *\n   * @return  Promise\n   */\n  textConverted() {\n    return consumeBody.call(this).then(buffer => convertBody(buffer, this.headers));\n  }\n\n};\n\nBody.mixIn = function (proto) {\n  for (const name of Object.getOwnPropertyNames(Body.prototype)) {\n    // istanbul ignore else: future proof\n    if (!(name in proto)) {\n      const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n      Object.defineProperty(proto, name, desc);\n    }\n  }\n};\n/**\n * Decode buffers into utf-8 string\n *\n * @return  Promise\n */\n\n\nfunction consumeBody(body) {\n  if (this[DISTURBED]) {\n    return Body.Promise.reject(new Error(`body used already for: ${this.url}`));\n  }\n\n  this[DISTURBED] = true; // body is null\n\n  if (this.body === null) {\n    return Body.Promise.resolve(Buffer.alloc(0));\n  } // body is string\n\n\n  if (typeof this.body === 'string') {\n    return Body.Promise.resolve(Buffer.from(this.body));\n  } // body is blob\n\n\n  if (this.body instanceof Blob) {\n    return Body.Promise.resolve(this.body[BUFFER]);\n  } // body is buffer\n\n\n  if (Buffer.isBuffer(this.body)) {\n    return Body.Promise.resolve(this.body);\n  } // istanbul ignore if: should never happen\n\n\n  if (!(this.body instanceof Stream)) {\n    return Body.Promise.resolve(Buffer.alloc(0));\n  } // body is stream\n  // get ready to actually consume the body\n\n\n  let accum = [];\n  let accumBytes = 0;\n  let abort = false;\n  return new Body.Promise((resolve, reject) => {\n    let resTimeout; // allow timeout on slow response body\n\n    if (this.timeout) {\n      resTimeout = setTimeout(() => {\n        abort = true;\n        reject(new FetchError(`Response timeout while trying to fetch ${this.url} (over ${this.timeout}ms)`, 'body-timeout'));\n      }, this.timeout);\n    } // handle stream error, such as incorrect content-encoding\n\n\n    this.body.on('error', err => {\n      reject(new FetchError(`Invalid response body while trying to fetch ${this.url}: ${err.message}`, 'system', err));\n    });\n    this.body.on('data', chunk => {\n      if (abort || chunk === null) {\n        return;\n      }\n\n      if (this.size && accumBytes + chunk.length > this.size) {\n        abort = true;\n        reject(new FetchError(`content size at ${this.url} over limit: ${this.size}`, 'max-size'));\n        return;\n      }\n\n      accumBytes += chunk.length;\n      accum.push(chunk);\n    });\n    this.body.on('end', () => {\n      if (abort) {\n        return;\n      }\n\n      clearTimeout(resTimeout);\n      resolve(Buffer.concat(accum));\n    });\n  });\n}\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */\n\n\nfunction convertBody(buffer, headers) {\n  const ct = headers.get('content-type');\n  let charset = 'utf-8';\n  let res, str; // header\n\n  if (ct) {\n    res = /charset=([^;]*)/i.exec(ct);\n  } // no charset in content type, peek at response body for at most 1024 bytes\n\n\n  str = buffer.slice(0, 1024).toString(); // html5\n\n  if (!res && str) {\n    res = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n  } // html4\n\n\n  if (!res && str) {\n    res = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n\n    if (res) {\n      res = /charset=(.*)/i.exec(res.pop());\n    }\n  } // xml\n\n\n  if (!res && str) {\n    res = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n  } // found charset\n\n\n  if (res) {\n    charset = res.pop(); // prevent decode issues when sites use incorrect encoding\n    // ref: https://hsivonen.fi/encoding-menu/\n\n    if (charset === 'gb2312' || charset === 'gbk') {\n      charset = 'gb18030';\n    }\n  } // turn raw buffers into a single utf-8 buffer\n\n\n  return convert(buffer, 'UTF-8', charset).toString();\n}\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */\n\n\nexports.clone = function clone(instance) {\n  let p1, p2;\n  let body = instance.body; // don't allow cloning a used body\n\n  if (instance.bodyUsed) {\n    throw new Error('cannot clone body after it is used');\n  } // check that body is a stream and not form-data object\n  // note: we can't clone the form-data object without having it as a dependency\n\n\n  if (body instanceof Stream && typeof body.getBoundary !== 'function') {\n    // tee instance body\n    p1 = new PassThrough();\n    p2 = new PassThrough();\n    body.pipe(p1);\n    body.pipe(p2); // set instance body to teed body and return the other teed body\n\n    instance.body = p1;\n    body = p2;\n  }\n\n  return body;\n};\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present and non-null.\n *\n * @param   Mixed  instance  Response or Request instance\n */\n\n\nexports.extractContentType = function extractContentType(instance) {\n  const body = instance.body; // istanbul ignore if: Currently, because of a guard in Request, body\n  // can never be null. Included here for completeness.\n\n  if (body === null) {\n    // body is null\n    return null;\n  } else if (typeof body === 'string') {\n    // body is string\n    return 'text/plain;charset=UTF-8';\n  } else if (body instanceof Blob) {\n    // body is blob\n    return body.type || null;\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n    return null;\n  } else if (typeof body.getBoundary === 'function') {\n    // detect form data input from form-data module\n    return `multipart/form-data;boundary=${body.getBoundary()}`;\n  } else {\n    // body is stream\n    // can't really do much about this\n    return null;\n  }\n};\n\nexports.getTotalBytes = function getTotalBytes(instance) {\n  const body = instance.body; // istanbul ignore if: included for completion\n\n  if (body === null) {\n    // body is null\n    return 0;\n  } else if (typeof body === 'string') {\n    // body is string\n    return Buffer.byteLength(body);\n  } else if (body instanceof Blob) {\n    // body is blob\n    return body.size;\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n    return body.length;\n  } else if (body && typeof body.getLengthSync === 'function') {\n    // detect form data input from form-data module\n    if ( // 1.x\n    body._lengthRetrievers && body._lengthRetrievers.length === 0 || // 2.x\n    body.hasKnownLength && body.hasKnownLength()) {\n      return body.getLengthSync();\n    }\n\n    return null;\n  } else {\n    // body is stream\n    // can't really do much about this\n    return null;\n  }\n};\n\nexports.writeToStream = function writeToStream(dest, instance) {\n  const body = instance.body;\n\n  if (body === null) {\n    // body is null\n    dest.end();\n  } else if (typeof body === 'string') {\n    // body is string\n    dest.write(body);\n    dest.end();\n  } else if (body instanceof Blob) {\n    // body is blob\n    dest.write(body[BUFFER]);\n    dest.end();\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n    dest.write(body);\n    dest.end();\n  } else {\n    // body is stream\n    body.pipe(dest);\n  }\n}; // expose Promise\n\n\nBody.Promise = global.Promise;","map":null,"metadata":{},"sourceType":"script"}