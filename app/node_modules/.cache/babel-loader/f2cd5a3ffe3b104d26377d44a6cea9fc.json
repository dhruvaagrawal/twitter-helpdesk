{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst fs = require('graceful-fs');\n\nconst chain = require('slide').chain;\n\nconst mkdir = require('./mkdir.js');\n\nconst rm = require('./rm.js');\n\nconst inferOwner = require('infer-owner');\n\nconst chown = require('./chown.js');\n\nexports = module.exports = {\n  link: link,\n  linkIfExists: linkIfExists\n};\n\nfunction linkIfExists(from, to, opts, cb) {\n  opts.currentIsLink = false;\n  opts.currentExists = false;\n  fs.stat(from, function (er) {\n    if (er) return cb();\n    fs.readlink(to, function (er, fromOnDisk) {\n      if (!er || er.code !== 'ENOENT') {\n        opts.currentExists = true;\n      } // if the link already exists and matches what we would do,\n      // we don't need to do anything\n\n\n      if (!er) {\n        opts.currentIsLink = true;\n        var toDir = path.dirname(to);\n        var absoluteFrom = path.resolve(toDir, from);\n        var absoluteFromOnDisk = path.resolve(toDir, fromOnDisk);\n        opts.currentTarget = absoluteFromOnDisk;\n        if (absoluteFrom === absoluteFromOnDisk) return cb();\n      }\n\n      link(from, to, opts, cb);\n    });\n  });\n}\n\nfunction resolveIfSymlink(maybeSymlinkPath, cb) {\n  fs.lstat(maybeSymlinkPath, function (err, stat) {\n    if (err) return cb.apply(this, arguments);\n    if (!stat.isSymbolicLink()) return cb(null, maybeSymlinkPath);\n    fs.readlink(maybeSymlinkPath, cb);\n  });\n}\n\nfunction ensureFromIsNotSource(from, to, cb) {\n  resolveIfSymlink(from, function (err, fromDestination) {\n    if (err) return cb.apply(this, arguments);\n\n    if (path.resolve(path.dirname(from), fromDestination) === path.resolve(to)) {\n      return cb(new Error('Link target resolves to the same directory as link source: ' + to));\n    }\n\n    cb.apply(this, arguments);\n  });\n}\n\nfunction link(from, to, opts, cb) {\n  to = path.resolve(to);\n  opts.base = path.dirname(to);\n  var absTarget = path.resolve(opts.base, from);\n  var relativeTarget = path.relative(opts.base, absTarget);\n  var target = opts.absolute ? absTarget : relativeTarget;\n  const tasks = [[ensureFromIsNotSource, absTarget, to], [fs, 'stat', absTarget], [clobberLinkGently, from, to, opts], [mkdir, path.dirname(to)], [fs, 'symlink', target, to, 'junction']];\n\n  if (chown.selfOwner.uid !== 0) {\n    chain(tasks, cb);\n  } else {\n    inferOwner(to).then(owner => {\n      tasks.push([chown, to, owner.uid, owner.gid]);\n      chain(tasks, cb);\n    });\n  }\n}\n\nexports._clobberLinkGently = clobberLinkGently;\n\nfunction clobberLinkGently(from, to, opts, cb) {\n  if (opts.currentExists === false) {\n    // nothing to clobber!\n    opts.log.silly('gently link', 'link does not already exist', {\n      link: to,\n      target: from\n    });\n    return cb();\n  }\n\n  if (!opts.clobberLinkGently || opts.force === true || !opts.gently || typeof opts.gently !== 'string') {\n    opts.log.silly('gently link', 'deleting existing link forcefully', {\n      link: to,\n      target: from,\n      force: opts.force,\n      gently: opts.gently,\n      clobberLinkGently: opts.clobberLinkGently\n    });\n    return rm(to, opts, cb);\n  }\n\n  if (!opts.currentIsLink) {\n    opts.log.verbose('gently link', 'cannot remove, not a link', to); // don't delete.  it'll fail with EEXIST when it tries to symlink.\n\n    return cb();\n  }\n\n  if (opts.currentTarget.indexOf(opts.gently) === 0) {\n    opts.log.silly('gently link', 'delete existing link', to);\n    return rm(to, opts, cb);\n  } else {\n    opts.log.verbose('gently link', 'refusing to delete existing link', {\n      link: to,\n      currentTarget: opts.currentTarget,\n      newTarget: from,\n      gently: opts.gently\n    });\n    return cb();\n  }\n}","map":null,"metadata":{},"sourceType":"script"}